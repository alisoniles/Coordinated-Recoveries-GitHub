---
title: "3b_EDM_CCM_for_MPGs"
author: "Alison Iles"
date: "7/30/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#load the necessary packages. 
Note that the `echo = FALSE` parameter prevents printing of the R code.

```{r, echo=FALSE}
library(rEDM)
library(reshape2)
library(rgl)
library(ggplot2)
library(gridExtra)
library(xtable)
library(rlist)

```


#Convergent Cross Mapping (CCM) with time delays
To test whether pairwise causality exists between the environmental variables and the spawner recruit relationship. Also to test all the lags for each environmental variable to figure out which is the best to use in the multivariate embeddings.

We tested all monthly values of PDO, Upwelling index (for both 45 and 48 degrees latitude) and NPGO, even though with have apriori knowledge of which months are likely the most important for salmon. 

block_lnlp uses multiple time series given as input to generate an attractor reconstruction, and then applies the simplex projection or s-map algorithm to make forecasts. This method generalizes the simplex and s_map routines, and allows for "mixed" embeddings, where multiple time series can be used as different dimensions of an attractor reconstruction.


```{r}

compute_ccm <- function(data, name)
{
    #concatenate the time series of each variable together
        keys <-c(names(data[[1]]))
        merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
        merged_data <- as.data.frame(merged_data)
        valid <- is.finite(merged_data$rec4_n) & is.finite(merged_data$rec5_n) & is.finite(merged_data$eff_n)
        block <- merged_data[valid,]  
        
    #List in lib the begin and end points of each stock
        lib <- matrix(NA, nrow = length(data), ncol = 2)
          lib[,1] <- c(1, which(diff(block$yr)<0)+1)
          lib[,2] <- c(which(diff(block$yr)<0), nrow(block))
          ## NOTE: need to remove non-continuous years from some stocks
     
        env_names <- c(names(data[[1]][28:77]))

  
        ccm_table <- do.call(cbind, lapply(env_names, function(env_var) 
          {
            output <- block_lnlp(block, lib, tp = 0, target_column = env_var, 
                                 columns = c("rec4_n", "rec5_n", "eff_n"), silent = TRUE)
            return(output$rho)
        }))
        colnames(ccm_table) <- env_names
        ccm_table <- cbind(N = sum(valid), ccm_table)
        rownames(ccm_table) <- name
        
        ccm_table <- as.data.frame(ccm_table)
        ccm_table <- cbind("N" = ccm_table$N,
                       "95% p" = tanh(qnorm(0.95, sd = 1/sqrt(ccm_table$N - 3))), 
                       ccm_table[,2:NCOL(ccm_table)])
        ccm_table <- xtable(ccm_table, digits = 3)

        saveRDS(ccm_table, file = paste("Output/Rdata/results_ccm_",name,".RDS", sep = "", collapse = NULL))
    
    return()
}

###--- nonlinear test for different major population groups
load("Data/Rdata/block_data.Rdata")  
mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
  
  for(u in 1:5){
    data <- block_data[c(mpg==u)]
    name <- as.character(data[[1]]$mpg[1])
    compute_ccm(data, name)
  }

    ccm_table_I <- data.frame(readRDS("Output/Rdata/results_ccm_Imnaha.RDS"))
    ccm_table_LS <- data.frame(readRDS("Output/Rdata/results_ccm_Lower Snake.RDS"))
    ccm_table_MFS <- data.frame(readRDS("Output/Rdata/results_ccm_Middle Fork Salmon.RDS"))
    ccm_table_SFS <- data.frame(readRDS("Output/Rdata/results_ccm_South Fork Salmon.RDS"))
    ccm_table_US <- data.frame(readRDS("Output/Rdata/results_ccm_Upper Salmon.RDS"))
    
    ccm_table <- rbind(ccm_table_I, ccm_table_LS, ccm_table_MFS, ccm_table_SFS, ccm_table_US)
    
    print(ccm_table, type = "html", file = "Output/Tables/Table_S3.html")
```
