---
title: "5_EDM_Multivariate_forecast_models"
author: "Alison Iles"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(ggplot2)
library(rEDM)
library(plyr)
library(reshape)
```

Excerpt from methods of McGowen et al.: With multiple environmental drivers to choose from, there are many ways to construct multivariate models (Ye and Sugihara 2016). We limit our models to a maximum of four coordinates to keep
the analysis tractable and to be consistent with the optimal E determined for the univariate model. Fixing the
first coordinate to be the unlagged chlorophyll-a concentration, we consider up to three additional coordinates, where each other coordinate is a 0-, 1-, or 2-week lag of either an environmental variable or of chlorophyll-a. We use all environmental variables that CCM identifies as significant. Choosing combinations of the six causal environmental variables listed in Table 1 generates 1351 possible multivariate models.

```{r}
load("Data/Rdata/block_data.Rdata")  
mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
for(u in c(1,2,3,5)){ #For each MPG excluding lower Snake for which there is only one stock
    data <- block_data[c(mpg==u)]
    mpgname <- as.character(data[[1]]$mpg[1])
    
#concatenate the time series of the different stocks in the MPG together
    keys <-c(names(data[[1]]))
    merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
    merged_data <- as.data.frame(merged_data)
    valid <-  is.finite(merged_data$rec_n) & is.finite(merged_data$eff_n)
    block <- merged_data[valid,]  
    
    #List in lib the begin and end points of each stock and the break points within stocks
    lib <- matrix(NA, nrow = length(which(diff(block$yr)!=1))+1, ncol = 2)
    lib[,1] <- c(1, which(diff(block$yr)!=1)+1)
    lib[,2] <- c(which(diff(block$yr)!=1), nrow(block))

    # determine the best univariate embedding dimension and theta for the target variable (total recruitment)
    target_var <- "rec4_n"
    data_target <- as.matrix(cbind(block$yr, block[target_var]))
    rownames(data_target) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
    simplex_output <- simplex(data_target, E = 1:10, silent = TRUE)
    best_E <- simplex_output$E[which.max(simplex_output$rho)] #Apply optimal E that maximizes rho to the following CCM...
    smap_output <- s_map(data_target, lib=lib, pred=lib, E=best_E) 
    best_T <- smap_output$theta[which.max(smap_output$rho)] 
            
    #determine all the combinations of library variables to test        
    vars <- readRDS(paste("Output/Rdata/3_CCM_multivar_MPG_",mpgname,".RDS", sep = ""))
    vars[,9:12] <- matrix(0, nrow = NROW(ccm), ncol = 4)
    colnames(vars) <- c("variable" ,  "target",  "cat", "subcat", "offset", "rho",  "N",  "95p_crit", "rec3 vars", "rec4 vars", "rec5 vars", "Total rec vars")
vars$offset==2

        # plot the distribution of rho values: ggplot(ccm, aes(x=rho, color=library)) + geom_histogram(fill="white")
    ccm <- ccm %>% filter(library==target_var) %>% filter(!grepl('up45', env_fac)) #focus on total recruits and remove upwelling at 45 degrees
    # Top two months of PDO, NPGO, and Upwelling 48 at lags 2, 3, 4 (only for rec4 and rec5), and 5 (only for rec5)
    # Seal lion pup count data: offset by 3 years, then lag 2 and return year
    # Male count not offset: lag 2 and return year
    # Orcas are not eating smolts, only include return year lag.
    ccm <- ccm[ccm$rho>(3*ccm$`95p_crit`),] #only include variables whose CCM rho was 2* the critical value
    fac_combn <- t(combn(ccm$target, m=best_E-3, FUN = NULL, simplify = TRUE))  # Generate all combinations of variables in sets the size of the embedding dimension minus 2 because recruits 3 and the number of effective spawners are included by default. 
    
    #set up output table
    MultiEDM_outputlist <- matrix(NA, nrow = NROW(fac_combn), ncol = best_E + 4)
    colnames(MultiEDM_outputlist) <- c("MPG","target","rec3_n","eff_n","library1","library2","library3","library4","library5","library6","library7", "rho", "N", "95p_crit")
    MultiEDM_outputlist[,1] <- mpgname
    MultiEDM_outputlist[,2] <- target_var
    MultiEDM_outputlist[,3] <- "rec3_n"  
    MultiEDM_outputlist[,4] <- "eff_n"    
    MultiEDM_outputlist[,5:(best_E - 3 + 4)] <- fac_combn    

#Perform multivariate forecasts
    for(i in c(1:NROW(MultiEDM_outputlist)) ){  
    
      library_vars <- c(MultiEDM_outputlist[i,3:(best_E+1)])

          # CCM from library var to target var   
            MultiEDM_data <- as.matrix(cbind(block$yr, block[target_var], block[library_vars]))
            rownames( MultiEDM_data) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
            MultiEDM <-  block_lnlp(MultiEDM_data, lib, pred=lib, columns = library_vars, target_column = target_var, method = c("s-map"), theta=best_T, silent = TRUE, first_column_time = TRUE)
            MultiEDM_outputlist[i,NCOL(MultiEDM_outputlist)-2] <- MultiEDM$rho
            MultiEDM_outputlist[i,NCOL(MultiEDM_outputlist)-1] <- MultiEDM$num_pred
            MultiEDM_outputlist[i,NCOL(MultiEDM_outputlist)] <- qnorm(0.95, sd = 1/sqrt(MultiEDM$num_pred - 3)) #qnorm is used to look up percentiles of the standard normal distribution. The 0.95 quantile is the 95th percentile. qnorm produces the boundary value that the rho needs to be greater than. 
    }
    
saveRDS(MultiEDM_outputlist, file = paste("Output/Rdata/5_Multi_EDM_MPG_",mpgname,".RDS", sep = ""), compress = FALSE)
    
#figure
# plot the distribution of rho values
MultiEDM_outputlist <- data.frame(MultiEDM_outputlist)
MultiEDM_outputlist$rho <- as.numeric(as.character(MultiEDM_outputlist$rho))
ggplot(MultiEDM_outputlist, aes(x=rho)) + geom_histogram()
      
}
```

