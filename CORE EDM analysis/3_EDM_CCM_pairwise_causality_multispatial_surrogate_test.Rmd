---
title: "3_EDM_CCM_pairwise_causality_multispatial"
author: "Alison Iles"
date: "10/5/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(rEDM)
library(multispatialCCM)
library(tidyr)
library(stringr)

library(ggplot2)
library(ggforce)
library(gridExtra)
library(tictoc)
```


#run multispatial convergent cross-mapping algorithm on two time series, A and B, to determine whether process A is a forcing process for process B. 

prints rho for each multispatial CCM test and colors if significantly different from the min library size and significantly different compared to twin surrogates. 


#load the data and functions
```{R}
rm(list=ls()) 

#data <- data[,c("year", An, Bn)]; min_stock_size = 20 
#Function to remove to extra NAs, but leave one NA between each stock's data in an MPG
#'data' with columns, year, focal variable and any putative causal variable
shape_block_data <- function(data, min_stock_size = 30) {
  
         data <- rbind(c(NA,NA,NA),data) #add an initial row of NA so the difference function works for the first row
         
         dataNA <- (is.na(data[,3]) | is.na(data[,2])) # if there is no data for the causal variable, remove the Chinook data too at this point.
         data[dataNA,1:3] <- NA
         rownames(data) <- NULL
  
         #record the beginning and endpoints of each data chunk
         CC <- complete.cases(data[,2])  
         lib <- matrix(NA, nrow = length(which(diff(CC)==1)), ncol = 2)
                lib[,1] <- which(diff(CC)==1)+1
                lib[,2] <- which(diff(CC)==-1)
                colnames(lib) <- c("lower", "upper")
         
         #only include in the library the sections of data that are continuous for at least 20 time points. 
         minlib <- lib[,2]-lib[,1]+1
         #if there are no library chunks long enough, then return error
         if(sum(minlib>=min_stock_size)<=1){
           print("Error - data chunks are too small for the given E and tau")
           return()
         }
         lib <- as.matrix(lib[(minlib>=min_stock_size),])
         
         x <- c(NA, NA, NA)
             for (r in 1:nrow(lib)){
                 xtmp <- data[lib[r,1]:lib[r,2],]
                 x <- rbind(x,c(NA, NA, NA),xtmp)}
         data <- (x[3:nrow(x),])
         data <- as.data.frame(data)
         rownames(data) <- NULL
         
         data <- as.matrix(data)
         data <- cbind(as.numeric(data[,1]), as.numeric(data[,2]), as.numeric(data[,3]))
         colnames(data) <- c("year", "rec", "PCV")
         return(data)
}

#modified ccmtest function to test one-way interactions (we're only interested in the effects on salmon, not what salmon affect and most of the variables are exogenous anyway)

ccmtest_oneway <- function(CCM_boot_AcB) {
    #Tests for significant causal signal based on 95%
    #confidence intervals from bootstrapping.
    #Compares shortest library to longest
    pval_a_cause_b<-1-sum(CCM_boot_AcB$FULLinfo[1,]<
      CCM_boot_AcB$FULLinfo[nrow(CCM_boot_AcB$FULLinfo),], na.rm=T)/
      ncol(CCM_boot_AcB$FULLinfo)
    return(pval_a_cause_b)
  }


#Run the multispatial convergent cross mapping algorithm on A causing B and B causing A. 
# This function runs the multispatial CCM_boot and tests output from CCM_boot for significant causal signal using ccmtest to compare the 95% confidence intervals for estimated rho for the shortest and longest libraries calculated, and uses this to determine whether predictive power has significantly increased.  Reorganizes the output into a data frame for plotting. 
# Desired library lengths for which to compute CCM. Defaults to the maximum possible length ((tau * (E - 1) + (E + 1)):length(A) - E + 2) (though number of resulting predictions may be smaller because of gaps in the time series). Shortening this list (e.g., only predicting every nth element) will reduce run-time for the algorithm, but may also reduce ability to detect causal relations.
#A <- AB[,2]; B <- AB[,3]; An <- An; Bn <- Bn; EB <- EB; tau <- tau
CCM_boot_df_and_sig_test <- function(A, B, An, Bn, EB, tau)
    {
          DL <- c((tau * (EB - 1) + (EB + 1)), (length(A) - EB + 2))
          
          CCM_BcA <- CCM_boot(B, A, EB, tau=tau, DesiredL=DL, iterations=500) # Does B "cause" A?
          CCM_A_B_sig_test<-ccmtest_oneway(CCM_BcA)

          #make data frame of results for output
          BcA_df <- as.data.frame(cbind(CCM_BcA$Lobs, CCM_BcA$rho, CCM_BcA$sdevrho, (CCM_BcA$rho-CCM_BcA$sdevrho), (CCM_BcA$rho+CCM_BcA$sdevrho)))
          colnames(BcA_df) <- c("Lobs", "rho", "sdevrho", "lower", "upper")
          
          BcA_df$model <- paste(Bn, " causes ", An, ", p = ", signif(CCM_A_B_sig_test,2) , sep="")
          BcA_df$response_var <- An
          BcA_df$causal_var <- Bn
          BcA_df$pval <- signif(CCM_A_B_sig_test,2)
          BcA_df$E <- EB
          BcA_df$tau <- tau
          
          #estimate slope of rho values as a function of library size for the largest 1/4 of library sizes
          D <- BcA_df[BcA_df$Lobs > (max(BcA_df$Lobs, na.rm=TRUE)*0.75),]
          BcA_df$slope <- lm(D$rho ~D$Lobs)$coefficients[2]
           
          return(BcA_df)
    }



#create list of beginning and end points for chunks of time series combined in the same embedding. Year must be in the first column of the time series. Complete cases only. Removes sections that are not continuous for at least 18 time points. Returns lib and the narrowed data block. 
    create_lib <- function(d, cont_tp)
{
         lib <- matrix(NA, nrow = length(which(diff(d[,1])!=1))+1, ncol = 2) 
             lib[,1] <- c(1, which(diff(d[,1])!=1)+1)
             lib[,2] <- c(which(diff(d[,1])!=1), nrow(d))
        
         minlib <- lib[,2]-lib[,1] #only include in the library the sections of data that are continuous for at least 'cont_tp' time points. 
         lib <- lib[minlib>=cont_tp,] 
             
    return(lib)
    }

    
    
load("Data/Rdata/block_data.Rdata")  
      aa <- t(data.frame(as.list(names(block_data[[1]]))))
          rownames(aa) <- NULL #remove rownames
      bb <- data.frame(c(aa[31:nrow(aa)] ))
          colnames(bb) <- c("variable")
      cc <- str_split_fixed(bb$variable, "[.]",n=3)
      var_list <- cbind(bb,cc)
      
      var_list[,5:21] <- matrix(NA, nrow = NROW(var_list), ncol = 17)
      
      colnames(var_list) <- c("target", "cat", "subcat", "offset", "E",
                              "ESU rho","ESU sd", "ESU pval", "ESU slope", 
                              "MFS rho","MFS sd", "MFS pval", "MFS slope", 
                              "IMN rho","IMN sd", "IMN pval", "IMN slope",
                              "UPS rho","UPS sd", "UPS pval", "UPS slope")     
      var_list$offset <- as.numeric(var_list$offset)
      rm("aa", "bb", "cc")
      
      vars <- c("stk", "year", "salm.rec4n.0", "salm.rec5n.0", "salm.recspn4n.0", "salm.recspn5n.0", var_list$target) 

#concatenate the stock time series together for each MPG and ESU to create input data frames for the CCM functions
D_ESU <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA,  
              block_data$'Big Creek'[vars], NA,  
              block_data$'Camas Creek'[vars], NA,  
              block_data$'Catherine Creek'[vars], NA,  
              block_data$'East Fork Salmon River'[vars], NA,  
              block_data$'East Fork South Fork'[vars], NA,  
              block_data$'Grande Ronde Upper Mainstem'[vars], NA,  
              block_data$'Imnaha River'[vars], NA,  
              block_data$'Lemhi River'[vars], NA,  
              block_data$'Loon Creek'[vars], NA,  
              block_data$'Lostine River'[vars], NA,  
              block_data$'Marsh Creek'[vars], NA,  
              block_data$'Minam River'[vars], NA,    
              block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,  
              block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA,  
              block_data$'Secesh River'[vars], NA,  
              block_data$'South Fork Salmon River Mainstem'[vars], NA,  
              block_data$'Sulphur Creek'[vars], NA,   
              block_data$'Valley Creek'[vars], NA,  
              block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA,  
              block_data$'Wenaha River'[vars], NA,  
              block_data$'Yankee Fork'[vars]))

D_MFS <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
           block_data$'Big Creek'[vars], NA, 
           block_data$'Camas Creek'[vars], NA, 
           block_data$'Loon Creek'[vars], NA, 
           block_data$'Marsh Creek'[vars], NA, 
           block_data$'Sulphur Creek'[vars]))

D_IMN <- as.matrix(rbind(block_data$'Catherine Creek'[vars], NA, 
                     block_data$'Grande Ronde Upper Mainstem'[vars], NA, 
                     block_data$'Imnaha River'[vars], NA, 
                     block_data$'Lostine River'[vars], NA, 
                     block_data$'Minam River'[vars], NA, 
                     block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA, 
                     block_data$'Wenaha River'[vars], NA))
  
D_UPS <- as.matrix(rbind(block_data$'East Fork Salmon River'[vars], NA, 
                     block_data$'Lemhi River'[vars], NA, 
                     block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA, 
                     block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA, 
                     block_data$'Valley Creek'[vars], NA, 
                     block_data$'Yankee Fork'[vars], NA))



```





```{R}
#shape causal variable list, output data frame and input data frames for the CCM functions

#Choose the focal variable to run the analysis for
for(a in (1)){
  An_list <-  c("salm.recspn4n.0") #"salm.recspn4n.0", 
  An <- An_list[a]
  An_short_list <- c("recspn4") #, "recspn5")
  An_short <- An_short_list[a]

for(l in (1:4)){
  level_list <- c("MFS", "UPS", "IMN")
  level <- level_list[l]

#Clusters identified in '2_Clustering_Chinook_stocks.Rmd'
#For recspn5n:
if(An_short=="recspn5"){
MFS_1 <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
           block_data$'Big Creek'[vars], NA, 
           block_data$'Marsh Creek'[vars]))

MFS_2 <- as.matrix(rbind(block_data$'Sulphur Creek'[vars], NA,  
                         block_data$'Loon Creek'[vars], NA,  
                     block_data$'Camas Creek'[vars], NA))

UPS_1 <- as.matrix(rbind(block_data$block_data$'Lemhi River'[vars], NA, 
                     block_data$'Yankee Fork'[vars], NA, 
                     block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,
                     block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA))

IMN_1 <- as.matrix(rbind(block_data$'Grande Ronde Upper Mainstem'[vars], NA, 
                     block_data$'Imnaha River'[vars], NA, 
                     block_data$'Minam River'[vars], NA))

IMN_2 <- as.matrix(rbind(block_data$'Lostine River'[vars], NA, 
                     block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA, 
                     block_data$'Wenaha River'[vars], NA))

if(level=="ESU"){DataClusters <- list(D_ESU, D_MFS, D_IMN, D_UPS)
DataClusterNames <- c("ESU", "MFS", "IMN", "UPS")
names(DataClusters) <- DataClusterNames}

if(level=="MFS"){DataClusters <- list(D_MFS, MFS_1, MFS_2)
DataClusterNames <- c("MFS", "MFS_1", "MFS_2")
names(DataClusters) <- DataClusterNames}

if(level=="UPS"){DataClusters <- list(D_UPS, UPS_1, UPS_2)
DataClusterNames <- c("UPS", "UPS_1", "UPS_2")
names(DataClusters) <- DataClusterNames}

if(level=="IMN"){DataClusters <- list(D_IMN, IMN_1, IMN_2)
DataClusterNames <- c("IMN", "IMN_1", "IMN_2")
names(DataClusters) <- DataClusterNames}

}

#For recspn4n:
if(An_short=="recspn4"){
MFS_1 <- as.matrix(rbind(block_data$'Marsh Creek'[vars], NA,  
                     block_data$'Loon Creek'[vars], NA,
                      block_data$'Bear Valley Creek'[vars], NA, 
                     block_data$'Big Creek'[vars], NA, 
                     block_data$'Camas Creek'[vars]))

UPS_1 <- as.matrix(rbind(block_data$'East Fork Salmon River'[vars], NA, 
                     block_data$'Yankee Fork'[vars], NA, 
                     block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA, 
                     block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA))

IMN_1 <- as.matrix(rbind(block_data$'Catherine Creek'[vars], NA, 
                     block_data$'Imnaha River'[vars], NA, 
                     block_data$'Lostine River'[vars], NA, 
                     block_data$'Minam River'[vars], NA, 
                     block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA, 
                     block_data$'Wenaha River'[vars], NA))

if(level=="ESU"){DataClusters <- list(D_ESU, D_MFS, D_IMN, D_UPS)
DataClusterNames <- c("ESU", "MFS", "IMN", "UPS")
names(DataClusters) <- DataClusterNames}

if(level=="MFS"){DataClusters <- list(D_MFS, MFS_1)
DataClusterNames <- c("MFS", "MFS_1")
names(DataClusters) <- DataClusterNames}

if(level=="UPS"){DataClusters <- list(D_UPS, UPS_1)
DataClusterNames <- c("UPS", "UPS_1")
names(DataClusters) <- DataClusterNames}

if(level=="IMN"){DataClusters <- list(D_IMN, IMN_1)
DataClusterNames <- c("IMN", "IMN_1")
names(DataClusters) <- DataClusterNames}
}

CCM_summary <- matrix(data=NA, nrow=1, ncol=17); colnames(CCM_summary) <- c("Lobs", "rho", "sdevrho", "lower", "upper", "model", "response_var", "causal_var", "pval", "E", "tau", "slope", "Lib", "level", "cat", "subcat", "offset")      

unique_cat <- unique(var_list$cat) #for each unique putative causal variable category
c <- 2; s <- 2; i <- 1; dc <- 2
#Loop through all the lags of each putative causal variable and test for causality for the four main time series
for (c in 1:length(unique_cat)){
    cat_name <- unique_cat[c]    
    var_list_cat <- var_list[var_list$cat==cat_name,]
    unique_subcat <- unique(var_list_cat$subcat)
    for (s in 1:length(unique_subcat)){  #for each unique subcategory of the causal variable category 
        var_list_subcat <- var_list_cat[var_list_cat$subcat==unique_subcat[s],]
        subplot_list = list()
        for(i in nrow(var_list_subcat):1){  #for each offset of the causal variable subcategory
        Bn <- var_list_subcat[i,1]

tic()
        #find optimal E for putative causal variable
        D <- as.matrix(block_data$'Wenaha River'[c("year", Bn)])
        maxE<-floor(sqrt(sum(complete.cases(D)))) #Maximum E to test: E ≤ sqrt(n)
        Emat<-matrix(nrow=maxE-1, ncol=2); colnames(Emat)<-c("E", "Bn") #Matrix for storing output
            #Loop over potential E values and calculate predictive ability of each process for its own dynamics
            for(E in 2:maxE) {
              #Uses defaults of looking forward one prediction step (predstep)
              #And using time lag intervals of one time step (tau)
              Emat[E-1,"E"] <- E
              Emat[E-1,"Bn"]<-SSR_pred_boot(A=D, E=E, predstep=1, tau=1)$rho
            }
        #We defined E as the smallest dimension that came within 1% of the best predictive value observed across all dimensions with E ≤ sqrt(n), where
        #n is time series length (Sugihara & May 1990; Sugihara et al. 2012; Ye et al. 2015; Karacoc et at 2020). 
        maxrho=max(Emat[,"Bn"], na.rm=TRUE)
        EB <- min(Emat[(Emat[,"Bn"]>=(maxrho-(maxrho*0.01))),"E"], na.rm=TRUE)

        
        #run the multispatial CCM for each variable at each organizational level (ESU, MPGs and clusters) and record results
        for(dc in 1:length(DataClusters)){
          data <- DataClusters[[dc]]
          AB <- shape_block_data(data[,c("year", An, Bn)], min_stock_size = 20)
          if(is.null(AB)==FALSE){
                for(tau in 1:6){
                          CCM <- CCM_boot_df_and_sig_test(A=AB[,2], B=AB[,3], An=An, Bn=Bn, EB=EB, tau=tau)
                          CCM$Lib <- c("min", "max")
                          CCM$level <- DataClusterNames[dc]
                          if(tau==1){ CCM_all_tau <-CCM }
                          if(tau>1){ CCM_all_tau <- rbind(CCM_all_tau, CCM) }
                }
          CCM_all_tau$tau <- as.character(CCM_all_tau$tau)
          CCM_all_tau <- CCM_all_tau[CCM_all_tau$Lib=="max",]
          CCM_all_tau$cat <- var_list_subcat[i,2]
          CCM_all_tau$subcat <- var_list_subcat[i,3]
          CCM_all_tau$offset <- var_list_subcat[i,4]
                    CCM_summary <- rbind(CCM_summary, CCM_all_tau)
          }
          }

}
print(Bn)          
toc()         
}               
}


save(CCM_summary, file = paste("Output/Rdata/3_CCM/3_multispatial_results_", level, "_and_smaller_clusters_", An_short, ".Rdata", sep=""))

}#level loop
}#An loop
```

#figures 
```{R}
rm(list=ls()) 
level="IMN"
load(file = paste("Output/Rdata/3_CCM/3_multispatial_results_", level,"_and_smaller_clusters_recspn4.Rdata", sep=""))
CCM_4 <- CCM_summary[-1,]
load(file = paste("Output/Rdata/3_CCM/3_multispatial_results_", level,"_and_smaller_clusters_recspn5.Rdata", sep=""))
CCM_5 <- CCM_summary[-1,]
CCM_summary <- rbind(CCM_4, CCM_5)
CCM_summary$rec <- NA
CCM_summary$rec[CCM_summary$response_var=="salm.recspn4n.0"] <- 4
CCM_summary$rec[CCM_summary$response_var=="salm.recspn5n.0"] <- 5

harv_CCM <- CCM_summary[CCM_summary$cat=="harv",]
indexCCM <- c(which(harv_CCM$cat=="harv" & harv_CCM$rec==harv_CCM$offset) , 
                    which(harv_CCM$causal_var=="harv.SPSS.0"))
harv_CCM <- harv_CCM[indexCCM,]
harv_CCM$vargroup <- "fisheries harvest"

hatch_CCM <- CCM_summary[CCM_summary$cat=="hatch",]
hatch_CCM$vargroup <- "hatchery releases"

biotic_CCM <- CCM_summary[CCM_summary$cat=="orca" | CCM_summary$cat=="csl" | CCM_summary$cat=="ssl" | CCM_summary$cat=="hseal",]
biotic_CCM <- biotic_CCM[c(which(biotic_CCM$rec==biotic_CCM$offset)),]
biotic_CCM$vargroup <- "predation return year"

abiotic_CCM <- CCM_summary[CCM_summary$cat=="pdo" | CCM_summary$cat=="npgo" | CCM_summary$cat=="upw" | CCM_summary$cat=="arc",]
abiotic_return_year_CCM <- abiotic_CCM[c(which(abiotic_CCM$rec==abiotic_CCM$offset)),]
abiotic_return_year_CCM$vargroup <- "return year"

abiotic_first_ocean_year_CCM <- abiotic_CCM[abiotic_CCM$offset==2,]
abiotic_first_ocean_year_CCM$vargroup <- "first ocean year"

#flow_CCM <- CCM_summary[CCM_summary$cat=="flow",]
#flow_CCM$vargroup <- "river conditions"

CCM <- rbind(harv_CCM, hatch_CCM, biotic_CCM, abiotic_first_ocean_year_CCM, abiotic_return_year_CCM)
#CCM <- CCM[CCM$level=="D_ESU" | CCM$level=="D_MFS" | CCM$level=="D_IMN" |CCM$level=="D_UPS",]

manual_color_codes <- read.csv("Data/csv_data/CORE_CCM_figure_color_codes.csv") #csv file containing the manual color codes and labels for plots 
     mcc <- manual_color_codes[,1:3]
    
unique_cat <- unique(CCM$cat) #for each unique putative causal variable category

for(i in 1:length(unique_cat)){
cat <- unique_cat[i]
Dp <- CCM[CCM$cat==cat,]     
Dp <- Dp[Dp$pval<=0.8,]

p1 <- ggplot(Dp) + 
    geom_point(aes(x=pval, y=rho, color=subcat, shape=tau)) +
    #geom_errorbar(aes(x=pval, y=rho, color=subcat, ymin=lower, ymax=upper), width=0.01) +
    scale_x_continuous(name=expression(paste("p-value terminal ", {rho}, " > starting ", {rho})), limits=c(0, 0.4), breaks=seq(0,0.4,0.1), labels=c("0", "0.1", "0.2", "0.3", "0.4")) +
    scale_y_continuous(name=expression(paste("Terminal cross-mapping correlation, ", {rho})), limits=c(-0.2, 0.8), breaks=seq(-0.2,0.8,0.2)) +
    geom_vline(aes(xintercept=0.05), colour='#999999') +
    theme_bw() + 
    guides(col = guide_legend(ncol=1)) +
    labs(title= paste("CCM - ", cat,  Dp$vargroup[1])) + 
    #scale_color_manual(values = mcc[,1], name="subcat", breaks = mcc[,2], labels = mcc[,3]) +
    facet_grid(cat*vargroup*rec~level) +
       theme(strip.background = element_blank(), strip.placement = "outside")
print(p1)
ggsave(filename = paste("Output/Figures/3_CCM/Multispatial/", level, "_and_smaller_clusters_", cat, ".pdf", sep=""), plot = p1, width = 10, height = 7, units = "in") 
}




```


