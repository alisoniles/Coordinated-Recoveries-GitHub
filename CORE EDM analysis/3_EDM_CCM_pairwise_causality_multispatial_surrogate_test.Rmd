---
title: "3_EDM_CCM_pairwise_causality_multispatial"
author: "Alison Iles"
date: "10/5/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(rEDM)
library(multispatialCCM)
library(tidyr)
library(stringr)
library(dplyr)
library(ggplot2)
library(ggforce)
library(gridExtra)
library(tictoc)
library(treemap)
library(d3Tree)
```


#run multispatial convergent cross-mapping algorithm on two time series, A and B, to determine whether process A is a forcing process for process B. 

prints rho for each multispatial CCM test and colors if significantly different from the min library size and significantly different compared to twin surrogates. 


#load the data and functions
```{R}
rm(list=ls()) 

#data <- data[,c("year", An, Bn)]; min_stock_size = 20 
#Function to remove to extra NAs, but leave one NA between each stock's data in an MPG
#'data' with columns, year, focal variable and any putative causal variable
shape_block_data <- function(data, min_stock_size = 30) {
  
         data <- rbind(c(NA,NA,NA),data) #add an initial row of NA so the difference function works for the first row
         
         dataNA <- (is.na(data[,3]) | is.na(data[,2])) # if there is no data for the causal variable, remove the Chinook data too at this point.
         data[dataNA,1:3] <- NA
         rownames(data) <- NULL
  
         #record the beginning and endpoints of each data chunk
         CC <- complete.cases(data[,2])  
         lib <- matrix(NA, nrow = length(which(diff(CC)==1)), ncol = 2)
                lib[,1] <- which(diff(CC)==1)+1
                lib[,2] <- which(diff(CC)==-1)
                colnames(lib) <- c("lower", "upper")
         
         #only include in the library the sections of data that are continuous for at least 20 time points. 
         minlib <- lib[,2]-lib[,1]+1
         #if there are no library chunks long enough, then return error
         if(sum(minlib>=min_stock_size)<=1){
           print("Error - data chunks are too small for the given E and tau")
           return()
         }
         lib <- as.matrix(lib[(minlib>=min_stock_size),])
         
         x <- c(NA, NA, NA)
             for (r in 1:nrow(lib)){
                 xtmp <- data[lib[r,1]:lib[r,2],]
                 x <- rbind(x,c(NA, NA, NA),xtmp)}
         data <- (x[3:nrow(x),])
         data <- as.data.frame(data)
         rownames(data) <- NULL
         
         data <- as.matrix(data)
         data <- cbind(as.numeric(data[,1]), as.numeric(data[,2]), as.numeric(data[,3]))
         colnames(data) <- c("year", "rec", "PCV")
         return(data)
}

#modified ccmtest function to test one-way interactions (we're only interested in the effects on salmon, not what salmon affect and most of the variables are exogenous anyway)

ccmtest_oneway <- function(CCM_boot_AcB) {
    #Tests for significant causal signal based on 95%
    #confidence intervals from bootstrapping.
    #Compares shortest library to longest
    pval_a_cause_b<-1-sum(CCM_boot_AcB$FULLinfo[1,]<
      CCM_boot_AcB$FULLinfo[nrow(CCM_boot_AcB$FULLinfo),], na.rm=T)/
      ncol(CCM_boot_AcB$FULLinfo)
    return(pval_a_cause_b)
  }


#Run the multispatial convergent cross mapping algorithm on A causing B and B causing A. 
# This function runs the multispatial CCM_boot and tests output from CCM_boot for significant causal signal using ccmtest to compare the 95% confidence intervals for estimated rho for the shortest and longest libraries calculated, and uses this to determine whether predictive power has significantly increased.  Reorganizes the output into a data frame for plotting. 
# Desired library lengths for which to compute CCM. Defaults to the maximum possible length ((tau * (E - 1) + (E + 1)):length(A) - E + 2) (though number of resulting predictions may be smaller because of gaps in the time series). Shortening this list (e.g., only predicting every nth element) will reduce run-time for the algorithm, but may also reduce ability to detect causal relations.
#A <- AB[,2]; B <- AB[,3]; An <- An; Bn <- Bn; EB <- EB; tau <- tau
CCM_boot_df_and_sig_test <- function(A, B, An, Bn, EB, tau)
    {
          DL <- c((tau * (EB - 1) + (EB + 1)), (length(A) - EB + 2))
          
          CCM_BcA <- CCM_boot(B, A, EB, tau=tau, DesiredL=DL, iterations=500) # Does B "cause" A?
          CCM_A_B_sig_test<-ccmtest_oneway(CCM_BcA)

          #make data frame of results for output
          BcA_df <- as.data.frame(cbind(CCM_BcA$Lobs, CCM_BcA$rho, CCM_BcA$sdevrho, (CCM_BcA$rho-CCM_BcA$sdevrho), (CCM_BcA$rho+CCM_BcA$sdevrho)))
          colnames(BcA_df) <- c("Lobs", "rho", "sdevrho", "lower", "upper")
          
          BcA_df$model <- paste(Bn, " causes ", An, ", p = ", signif(CCM_A_B_sig_test,2) , sep="")
          BcA_df$response_var <- An
          BcA_df$causal_var <- Bn
          BcA_df$pval <- signif(CCM_A_B_sig_test,2)
          BcA_df$E <- EB
          BcA_df$tau <- tau
          
          #estimate slope of rho values as a function of library size for the largest 1/4 of library sizes
          D <- BcA_df[BcA_df$Lobs > (max(BcA_df$Lobs, na.rm=TRUE)*0.75),]
          BcA_df$slope <- lm(D$rho ~D$Lobs)$coefficients[2]
           
          return(BcA_df)
    }



#create list of beginning and end points for chunks of time series combined in the same embedding. Year must be in the first column of the time series. Complete cases only. Removes sections that are not continuous for at least 18 time points. Returns lib and the narrowed data block. 
    create_lib <- function(d, cont_tp)
{
         lib <- matrix(NA, nrow = length(which(diff(d[,1])!=1))+1, ncol = 2) 
             lib[,1] <- c(1, which(diff(d[,1])!=1)+1)
             lib[,2] <- c(which(diff(d[,1])!=1), nrow(d))
        
         minlib <- lib[,2]-lib[,1] #only include in the library the sections of data that are continuous for at least 'cont_tp' time points. 
         lib <- lib[minlib>=cont_tp,] 
             
    return(lib)
    }

    
    
load("Data/Rdata/block_data.Rdata")  
      aa <- t(data.frame(as.list(names(block_data[[1]]))))
          rownames(aa) <- NULL #remove rownames
      bb <- data.frame(c(aa[31:nrow(aa)] ))
          colnames(bb) <- c("variable")
      cc <- str_split_fixed(bb$variable, "[.]",n=3)
      var_list <- cbind(bb,cc)
      colnames(var_list) <- c("target", "cat", "subcat", "offset")   
      var_list$offset <- as.numeric(var_list$offset)
      rm("aa", "bb", "cc")
      
      vars <- c("stk", "year", "salm.rec4n.0", "salm.rec5n.0", "salm.recspn4n.0", "salm.recspn5n.0", var_list$target) 

#concatenate the stock time series together for each MPG and ESU to create input data frames for the CCM functions
D_ESU <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA,  
              block_data$'Big Creek'[vars], NA,  
              block_data$'Camas Creek'[vars], NA,  
              block_data$'Catherine Creek'[vars], NA,  
              block_data$'East Fork Salmon River'[vars], NA,  
              block_data$'East Fork South Fork'[vars], NA,  
              block_data$'Grande Ronde Upper Mainstem'[vars], NA,  
              block_data$'Imnaha River'[vars], NA,  
              block_data$'Lemhi River'[vars], NA,  
              block_data$'Loon Creek'[vars], NA,  
              block_data$'Marsh Creek'[vars], NA,  
              block_data$'Minam River'[vars], NA,    
              block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,  
              block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA,  
              block_data$'Secesh River'[vars], NA,  
              block_data$'South Fork Salmon River Mainstem'[vars], NA,  
              block_data$'Sulphur Creek'[vars], NA,   
              block_data$'Valley Creek'[vars], NA,  
              block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA,  
              block_data$'Wenaha River'[vars], NA,  
              block_data$'Yankee Fork'[vars]))

D_MFS <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
           block_data$'Big Creek'[vars], NA, 
           block_data$'Camas Creek'[vars], NA, 
           block_data$'Loon Creek'[vars], NA, 
           block_data$'Marsh Creek'[vars], NA, 
           block_data$'Sulphur Creek'[vars]))

D_IMN <- as.matrix(rbind(block_data$'Catherine Creek'[vars], NA, 
                     block_data$'Grande Ronde Upper Mainstem'[vars], NA, 
                     block_data$'Imnaha River'[vars], NA, 
                     block_data$'Minam River'[vars], NA, 
                     block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA, 
                     block_data$'Wenaha River'[vars], NA))
  
D_UPS <- as.matrix(rbind(block_data$'East Fork Salmon River'[vars], NA, 
                     block_data$'Lemhi River'[vars], NA, 
                     block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA, 
                     block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA, 
                     block_data$'Valley Creek'[vars], NA, 
                     block_data$'Yankee Fork'[vars], NA))


```





```{R}
#shape causal variable list, output data frame and input data frames for the CCM functions

#Choose the focal variable to run the analysis for
for(a in (1:2)){
  An_list <-  c("salm.recspn4n.0", "salm.recspn5n.0")
  An <- An_list[a]
  An_short_list <- c("recspn4", "recspn5")
  An_short <- An_short_list[a]

for(l in (1:4)){
  level_list <- c("MFS", "IMN", "UPS","ESU")
  level <- level_list[l]

  
  
#Clusters identified in '2_Clustering_Chinook_stocks.Rmd'
  #Groups based on clustering the stock-level CCM results
 #For recspn4n:
if(An_short=="recspn4"){
MFS_1 <- as.matrix(rbind(block_data$'Sulphur Creek'[vars], NA,  
                     block_data$'Loon Creek'[vars]))

MFS_2 <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
                     block_data$'Big Creek'[vars], NA, 
                     block_data$'Marsh Creek'[vars]))

UPS_1 <- as.matrix(rbind(block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA, 
                     block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars]))

UPS_2 <- as.matrix(rbind(block_data$'East Fork Salmon River'[vars], NA, 
                     block_data$'Valley Creek'[vars]))

UPS_3 <- as.matrix(rbind(block_data$'Lemhi River'[vars], NA, 
                     block_data$'Yankee Fork'[vars]))

IMN_1 <- as.matrix(rbind(block_data$'Wenaha River'[vars], NA, 
                     block_data$'Minam River'[vars], NA, 
                     block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars]))

IMN_2 <- as.matrix(rbind(block_data$'Imnaha River'[vars], NA, 
                     block_data$'Catherine Creek'[vars], NA, 
                     block_data$'Grande Ronde Upper Mainstem'[vars]))

D_1 <- as.matrix(rbind(block_data$'Camas Creek'[vars], NA,
                       block_data$'Catherine Creek'[vars], NA,
                       block_data$'Grande Ronde Upper Mainstem'[vars], NA,
                       block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA, 
                       block_data$'South Fork Salmon River Mainstem'[vars]))
  
D_2 <- as.matrix(rbind(block_data$'East Fork South Fork'[vars], NA, 
                       block_data$'Secesh River'[vars], NA,  
                       block_data$'Wenaha River'[vars], NA,
                       block_data$'Minam River'[vars]))

D_3 <- as.matrix(rbind(block_data$'Lemhi River'[vars], NA,
                      block_data$'Valley Creek'[vars], NA,               
                      block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA,
                      block_data$'East Fork Salmon River'[vars], NA,  
                      block_data$'Loon Creek'[vars], NA,  
                      block_data$'Yankee Fork'[vars], NA,
                      block_data$'Sulphur Creek'[vars]))

D_4 <- as.matrix(rbind(block_data$'Imnaha River'[vars], NA,
                       block_data$'Big Creek'[vars], NA,
                       block_data$'Marsh Creek'[vars], NA, 
                       block_data$'Bear Valley Creek'[vars], NA,  
                       block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars]))

if(level=="ESU"){DataClusters <- list(D_ESU, D_MFS, D_IMN, D_UPS, D_1, D_2, D_3, D_4)
DataClusterNames <- c("ESU", "MFS", "IMN", "UPS", "D_1", "D_2", "D_3", "D_4")
names(DataClusters) <- DataClusterNames}

if(level=="MFS"){DataClusters <- list(D_MFS, MFS_1, MFS_2)
DataClusterNames <- c("MFS", "MFS_1", "MFS_2")
names(DataClusters) <- DataClusterNames}

if(level=="UPS"){DataClusters <- list(D_UPS, UPS_1, UPS_2, UPS_3)
DataClusterNames <- c("UPS", "UPS_1", "UPS_2", "UPS_3")
names(DataClusters) <- DataClusterNames}

if(level=="IMN"){DataClusters <- list(D_IMN, IMN_1, IMN_2)
DataClusterNames <- c("IMN", "IMN_1", "IMN_2")
names(DataClusters) <- DataClusterNames}
}
  
  #For recspn5n:
if(An_short=="recspn5"){
MFS_1 <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
           block_data$'Sulphur Creek'[vars], NA, 
           block_data$'Marsh Creek'[vars]))

MFS_2 <- as.matrix(rbind(block_data$'Big Creek'[vars], NA,  
                         block_data$'Loon Creek'[vars], NA,  
                     block_data$'Camas Creek'[vars], NA))


UPS_1 <- as.matrix(rbind(block_data$'Lemhi River'[vars], NA, 
                         block_data$'East Fork Salmon River'[vars], NA, 
                     block_data$'Valley Creek'[vars]))

UPS_2 <- as.matrix(rbind(block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,
                     block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA))

IMN_1 <- as.matrix(rbind(block_data$'Wenaha River'[vars], NA, 
                     block_data$'Imnaha River'[vars], NA, 
                     block_data$'Minam River'[vars], NA))

IMN_2 <- as.matrix(rbind(block_data$'Catherine Creek'[vars], NA, 
                     block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA, 
                     block_data$'Grande Ronde Upper Mainstem'[vars], NA))

D_1 <- as.matrix(rbind(block_data$'Big Creek'[vars], NA, 
                       block_data$'Yankee Fork'[vars], NA,  
                       block_data$'Bear Valley Creek'[vars], NA, 
                       block_data$'Marsh Creek'[vars], NA,  
                       block_data$'Grande Ronde Upper Mainstem'[vars], NA,
                       block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,  
                       block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars]))
                        
D_2 <- as.matrix(rbind(block_data$'Valley Creek'[vars], NA,
                       block_data$'East Fork Salmon River'[vars], NA,  
                       block_data$'Lemhi River'[vars], NA,
                       block_data$'Catherine Creek'[vars], NA,  
                       block_data$'Camas Creek'[vars], NA,  
                       block_data$'Sulphur Creek'[vars], NA,   
                       block_data$'South Fork Salmon River Mainstem'[vars], NA,
                       block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars]))
                        
D_3 <- as.matrix(rbind(block_data$'Minam River'[vars], NA,
                       block_data$'Secesh River'[vars], NA, 
                       block_data$'Wenaha River'[vars]))

D_4 <- as.matrix(rbind(block_data$'Loon Creek'[vars], NA,  
                        block_data$'East Fork South Fork'[vars], NA,  
                        block_data$'Imnaha River'[vars]))

if(level=="ESU"){DataClusters <- list(D_ESU, D_MFS, D_IMN, D_UPS, D_1, D_2, D_3, D_4)
DataClusterNames <- c("ESU", "MFS", "IMN", "UPS", "D_1", "D_2", "D_3", "D_4")
names(DataClusters) <- DataClusterNames}

if(level=="MFS"){DataClusters <- list(D_MFS, MFS_1, MFS_2)
DataClusterNames <- c("MFS", "MFS_1", "MFS_2")
names(DataClusters) <- DataClusterNames}

if(level=="UPS"){DataClusters <- list(D_UPS, UPS_1, UPS_2)
DataClusterNames <- c("UPS", "UPS_1", "UPS_2")
names(DataClusters) <- DataClusterNames}

if(level=="IMN"){DataClusters <- list(D_IMN, IMN_1, IMN_2)
DataClusterNames <- c("IMN", "IMN_1", "IMN_2")
names(DataClusters) <- DataClusterNames}

}
 
  
  
#   #Groups based on clustering from Simplex analysis
#   #For recspn4n:
# if(An_short=="recspn4"){
# MFS_1 <- as.matrix(rbind(block_data$'Marsh Creek'[vars], NA,  
#                      block_data$'Loon Creek'[vars]))
# 
# MFS_2 <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
#                      block_data$'Big Creek'[vars], NA, 
#                      block_data$'Camas Creek'[vars]))
# 
# UPS_1 <- as.matrix(rbind(block_data$'East Fork Salmon River'[vars], NA, 
#                      block_data$'Yankee Fork'[vars], NA, 
#                      block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA, 
#                      block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars]))
# 
# UPS_2 <- as.matrix(rbind(block_data$'Lemhi River'[vars], NA, 
#                      block_data$'Valley Creek'[vars]))
# 
# IMN_1 <- as.matrix(rbind(block_data$'Catherine Creek'[vars], NA, 
#                      block_data$'Minam River'[vars], NA, 
#                      block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars]))
# 
# IMN_2 <- as.matrix(rbind(block_data$'Imnaha River'[vars], NA, 
#                      block_data$'Wenaha River'[vars], NA))
# 
# D_1 <- as.matrix(rbind(block_data$'Lemhi River'[vars], NA,
#                         block_data$'Valley Creek'[vars]))
# 
# D_2 <- as.matrix(rbind(block_data$'Secesh River'[vars], NA,  
#                         block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA,
#                         block_data$'Big Creek'[vars], NA,  
#                         block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars]))
# 
# D_3 <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA,  
#               block_data$'Catherine Creek'[vars], NA,  
#               block_data$'East Fork Salmon River'[vars], NA,  
#               block_data$'East Fork South Fork'[vars], NA,  
#               block_data$'Imnaha River'[vars], NA,  
#               block_data$'Loon Creek'[vars], NA,  
#               block_data$'Marsh Creek'[vars], NA,  
#               block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,  
#               block_data$'South Fork Salmon River Mainstem'[vars], NA,  
#               block_data$'Wenaha River'[vars]))
# 
# D_4 <- as.matrix(rbind(block_data$'Minam River'[vars], NA,
#                         block_data$'Camas Creek'[vars], NA,  
#                         block_data$'Yankee Fork'[vars]))
# 
# D_5 <- as.matrix(rbind(block_data$'Sulphur Creek'[vars], NA,   
#                         block_data$'Grande Ronde Upper Mainstem'[vars]))
#                       
# 
# if(level=="ESU"){DataClusters <- list(D_ESU, D_MFS, D_IMN, D_UPS, D4_1, D4_2, D4_3, D4_4, D4_5)
# DataClusterNames <- c("ESU", "MFS", "IMN", "UPS", "D4_1", "D4_2", "D4_3", "D4_4", "D4_5")
# names(DataClusters) <- DataClusterNames}
# 
# if(level=="MFS"){DataClusters <- list(D_MFS, MFS_1, MFS_2)
# DataClusterNames <- c("MFS", "MFS_1", "MFS_2")
# names(DataClusters) <- DataClusterNames}
# 
# if(level=="UPS"){DataClusters <- list(D_UPS, UPS_1, UPS_2)
# DataClusterNames <- c("UPS", "UPS_1", "UPS_2")
# names(DataClusters) <- DataClusterNames}
# 
# if(level=="IMN"){DataClusters <- list(D_IMN, IMN_1, IMN_2)
# DataClusterNames <- c("IMN", "IMN_1", "IMN_2")
# names(DataClusters) <- DataClusterNames}
# }
#   
#   #For recspn5n:
# if(An_short=="recspn5"){
# MFS_1 <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
#            block_data$'Big Creek'[vars], NA, 
#            block_data$'Marsh Creek'[vars]))
# 
# MFS_2 <- as.matrix(rbind(block_data$'Sulphur Creek'[vars], NA,  
#                          block_data$'Loon Creek'[vars], NA,  
#                      block_data$'Camas Creek'[vars], NA))
# 
# UPS_1 <- as.matrix(rbind(block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,
#                      block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars], NA))
# 
# UPS_2 <- as.matrix(rbind(block_data$'Lemhi River'[vars], NA, 
#                      block_data$'Yankee Fork'[vars]))
# 
# UPS_3 <- as.matrix(rbind(block_data$'East Fork Salmon River'[vars], NA, 
#                      block_data$'Valley Creek'[vars]))
# 
# IMN_1 <- as.matrix(rbind(block_data$'Grande Ronde Upper Mainstem'[vars], NA, 
#                      block_data$'Imnaha River'[vars], NA, 
#                      block_data$'Minam River'[vars], NA))
# 
# IMN_2 <- as.matrix(rbind(block_data$'Catherine Creek'[vars], NA, 
#                      block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars], NA, 
#                      block_data$'Wenaha River'[vars], NA))
# 
# D_1 <- as.matrix(rbind(block_data$'Bear Valley Creek'[vars], NA, 
#                         block_data$'Sulphur Creek'[vars], NA,   
#                         block_data$'South Fork Salmon River Mainstem'[vars], NA,  
#                         block_data$'Yankee Fork'[vars], NA,  
#                         block_data$'Loon Creek'[vars], NA,  
#                         block_data$'Lemhi River'[vars], NA,
#                         block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars], NA,  
#                         block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars]))
#                         
# D_2 <- as.matrix(rbind(block_data$'Secesh River'[vars], NA,  
#                         block_data$'East Fork Salmon River'[vars], NA,  
#                         block_data$'East Fork South Fork'[vars], NA,  
#                         block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars]))
#                         
# D_3 <- as.matrix(rbind(block_data$'Catherine Creek'[vars], NA,  
#                         block_data$'Camas Creek'[vars], NA,  
#                         block_data$'Wenaha River'[vars]))
# 
# D_4 <- as.matrix(rbind(block_data$'Big Creek'[vars], NA, 
#                         block_data$'Marsh Creek'[vars], NA,  
#                         block_data$'Valley Creek'[vars]))
# 
# D_5 <- as.matrix(rbind(block_data$'Imnaha River'[vars], NA,  
#                         block_data$'Minam River'[vars], NA,
#                         block_data$'Grande Ronde Upper Mainstem'[vars]))
# 
# if(level=="ESU"){DataClusters <- list(D_ESU, D_MFS, D_IMN, D_UPS, D4_1, D4_2, D4_3, D4_4, D4_5)
# DataClusterNames <- c("ESU", "MFS", "IMN", "UPS", "D4_1", "D4_2", "D4_3", "D4_4", "D4_5")
# names(DataClusters) <- DataClusterNames}
# 
# if(level=="MFS"){DataClusters <- list(D_MFS, MFS_1, MFS_2)
# DataClusterNames <- c("MFS", "MFS_1", "MFS_2")
# names(DataClusters) <- DataClusterNames}
# 
# if(level=="UPS"){DataClusters <- list(D_UPS, UPS_1, UPS_2, UPS_3)
# DataClusterNames <- c("UPS", "UPS_1", "UPS_2", "UPS_3")
# names(DataClusters) <- DataClusterNames}
# 
# if(level=="IMN"){DataClusters <- list(D_IMN, IMN_1, IMN_2)
# DataClusterNames <- c("IMN", "IMN_1", "IMN_2")
# names(DataClusters) <- DataClusterNames}
# 
# }
# 


CCM_summary <- matrix(data=NA, nrow=1, ncol=17); colnames(CCM_summary) <- c("Lobs", "rho", "sdevrho", "lower", "upper", "model", "response_var", "causal_var", "pval", "E", "tau", "slope", "Lib", "level", "cat", "subcat", "offset")      

unique_cat <- unique(var_list$cat) #for each unique putative causal variable category
c <- 2; s <- 2; i <- 1; dc <- 2
#Loop through all the lags of each putative causal variable and test for causality for the four main time series
for (c in 1:length(unique_cat)){
    cat_name <- unique_cat[c]    
    var_list_cat <- var_list[var_list$cat==cat_name,]
    unique_subcat <- unique(var_list_cat$subcat)
    for (s in 1:length(unique_subcat)){  #for each unique subcategory of the causal variable category 
        var_list_subcat <- var_list_cat[var_list_cat$subcat==unique_subcat[s],]
        subplot_list = list()
        for(i in nrow(var_list_subcat):1){  #for each offset of the causal variable subcategory
        Bn <- var_list_subcat[i,1]

tic()
        #find optimal E for putative causal variable
        D <- as.matrix(block_data$'Wenaha River'[c("year", Bn)])
        maxE<-floor(sqrt(sum(complete.cases(D)))) #Maximum E to test: E ≤ sqrt(n)
        Emat<-matrix(nrow=maxE-1, ncol=2); colnames(Emat)<-c("E", "Bn") #Matrix for storing output
            #Loop over potential E values and calculate predictive ability of each process for its own dynamics
            for(E in 2:maxE) {
              #Uses defaults of looking forward one prediction step (predstep)
              #And using time lag intervals of one time step (tau)
              Emat[E-1,"E"] <- E
              Emat[E-1,"Bn"]<-SSR_pred_boot(A=D, E=E, predstep=1, tau=1)$rho
            }
        #We defined E as the smallest dimension that came within 1% of the best predictive value observed across all dimensions with E ≤ sqrt(n), where
        #n is time series length (Sugihara & May 1990; Sugihara et al. 2012; Ye et al. 2015; Karacoc et at 2020). 
        maxrho=max(Emat[,"Bn"], na.rm=TRUE)
        EB <- min(Emat[(Emat[,"Bn"]>=(maxrho-(maxrho*0.01))),"E"], na.rm=TRUE)

        
        #run the multispatial CCM for each variable at each organizational level (ESU, MPGs and clusters) and record results
        for(dc in 1:length(DataClusters)){
          data <- DataClusters[[dc]]
          AB <- shape_block_data(data[,c("year", An, Bn)], min_stock_size = 20)
          if(is.null(AB)==FALSE){
                for(tau in 1:3){
                          CCM <- CCM_boot_df_and_sig_test(A=AB[,2], B=AB[,3], An=An, Bn=Bn, EB=EB, tau=tau)
                          CCM$Lib <- c("min", "max")
                          CCM$level <- DataClusterNames[dc]
                          if(tau==1){ CCM_all_tau <-CCM }
                          if(tau>1){ CCM_all_tau <- rbind(CCM_all_tau, CCM) }
                }
          CCM_all_tau$tau <- as.character(CCM_all_tau$tau)
          CCM_all_tau <- CCM_all_tau[CCM_all_tau$Lib=="max",]
          CCM_all_tau$cat <- var_list_subcat[i,2]
          CCM_all_tau$subcat <- var_list_subcat[i,3]
          CCM_all_tau$offset <- var_list_subcat[i,4]
                    CCM_summary <- rbind(CCM_summary, CCM_all_tau)
          }
        }
        


}
print(Bn)          
toc()         
}               
}


save(CCM_summary, file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level, "_and_clusters_based_on_stock_CCM_", An_short, ".Rdata", sep=""))


}#level loop
}#An loop
```



#CCM at the stock level
```{R}
#Narrow the stocks to those with large complete chunks
block <- list(block_data$'Bear Valley Creek'[vars],  
              block_data$'Big Creek'[vars],
              block_data$'Camas Creek'[vars],
              block_data$'Catherine Creek'[vars],
              block_data$'East Fork Salmon River'[vars],
              block_data$'East Fork South Fork'[vars],
              block_data$'Grande Ronde Upper Mainstem'[vars],
              block_data$'Imnaha River'[vars],
              block_data$'Lemhi River'[vars],
              block_data$'Loon Creek'[vars],
              block_data$'Marsh Creek'[vars],
              block_data$'Minam River'[vars],  
              block_data$'Salmon River Lower Mainstem below Redfish Lake'[vars],
              block_data$'Salmon River Upper Mainstem above Redfish Lake'[vars],
              block_data$'Secesh River'[vars],
              block_data$'South Fork Salmon River Mainstem'[vars],
              block_data$'Sulphur Creek'[vars], 
              block_data$'Valley Creek'[vars],
              block_data$'Wallowa River, Hurricane Creek, Bear Creek, and Lostine Rivers'[vars],
              block_data$'Wenaha River'[vars],
              block_data$'Yankee Fork'[vars])

a <- 2;v <- 1;j <- 1;tau <- 1
#Choose the focal variable to run the analysis for
An_list <-  c("salm.recspn4n.0", "salm.recspn5n.0")
An_short_list <- c("recspn4", "recspn5")
    tic()
    
for(a in (2:2)){
  An <- An_list[a]
  An_short <- An_short_list[a]
  
  #Empty matrix to store results
  stock_CCM_summary<- matrix(data=NA, nrow=1, ncol=10); colnames(stock_CCM_summary) <- c("stock", "response_var", "causal_var", "cat", "subcat", "offset", "E", "tau", "rho", "pval")     
  
  for (v in 1:nrow(var_list)){ #for each putative causal variable

    Bn <- var_list[v,1]

    #find optimal E for putative causal variable
    D <- as.matrix(block_data$'Wenaha River'[c("year", Bn)])
    maxE<-floor(sqrt(sum(complete.cases(D)))) #Maximum E to test: E ≤ sqrt(n)
    Emat<-matrix(nrow=maxE-1, ncol=2); colnames(Emat)<-c("E", "Bn") #Matrix for storing output
        #Loop over potential E values and calculate predictive ability of each process for its own dynamics
        for(E in 2:maxE) {
          #Uses defaults of looking forward one prediction step (predstep)
          #And using time lag intervals of one time step (tau)
          Emat[E-1,"E"] <- E
          Emat[E-1,"Bn"]<-SSR_pred_boot(A=D, E=E, predstep=1, tau=1)$rho
        }
    #We defined E as the smallest dimension that came within 1% of the best predictive value observed across all dimensions with E ≤ sqrt(n), where
    #n is time series length (Sugihara & May 1990; Sugihara et al. 2012; Ye et al. 2015; Karacoc et at 2020). 
    maxrho=max(Emat[,"Bn"], na.rm=TRUE)
    EB <- min(Emat[(Emat[,"Bn"]>=(maxrho-(maxrho*0.01))),"E"], na.rm=TRUE)


        #run the multispatial CCM for each stock separately
        for(j in 1:length(block)){ #for each stock
            for(tau in 1:3){ #for each tau
              tryCatch({
              data <- block[[j]] 
              data <- data[,c("year", An, Bn)]
              data <- data[complete.cases(data),]
              CCMboot <- CCM_boot(A=data[,3], B=data[,2], E=EB, tau=tau)
              CCM_sig_test<-ccmtest_oneway(CCMboot)
              out <- c(block[[j]]$stk[1],An,Bn,var_list[v,2],var_list[v,3],var_list[v,4],EB,tau,CCMboot$rho[length(CCMboot$rho)],CCM_sig_test)
              stock_CCM_summary <- rbind(stock_CCM_summary, out)
              }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
            }
        }
    
print(Bn)
   
  }
 toc()  
save(stock_CCM_summary, file = paste("Output/Rdata/3_CCM/stock_level/3_stock_results_", An_short, ".Rdata", sep=""))
}
```





#figures 
```{R}
rm(list=ls()) 
level="ESU"
load(file = paste("Output/Rdata/3_CCM/3_multispatial_results_", level,"_and_smaller_clusters_recspn4.Rdata", sep=""))
CCM_4 <- CCM_summary[-1,]
load(file = paste("Output/Rdata/3_CCM/3_multispatial_results_", level,"_and_smaller_clusters_recspn5.Rdata", sep=""))
CCM_5 <- CCM_summary[-1,]
CCM_summary <- rbind(CCM_4, CCM_5)
CCM_summary$rec <- NA
CCM_summary$rec[CCM_summary$response_var=="salm.recspn4n.0"] <- 4
CCM_summary$rec[CCM_summary$response_var=="salm.recspn5n.0"] <- 5

harv_CCM <- CCM_summary[CCM_summary$cat=="harv",]
indexCCM <- c(which(harv_CCM$cat=="harv" & harv_CCM$rec==harv_CCM$offset) , 
                    which(harv_CCM$causal_var=="harv.SPSS.0"))
harv_CCM <- harv_CCM[indexCCM,]
harv_CCM$vargroup <- "fisheries harvest"

hatch_CCM <- CCM_summary[CCM_summary$cat=="hatch",]
hatch_CCM$vargroup <- "hatchery releases"

biotic_CCM <- CCM_summary[CCM_summary$cat=="orca" | CCM_summary$cat=="csl" | CCM_summary$cat=="ssl" | CCM_summary$cat=="hseal",]
biotic_CCM <- biotic_CCM[c(which(biotic_CCM$rec==biotic_CCM$offset)),]
biotic_CCM$vargroup <- "predation return year"

abiotic_CCM <- CCM_summary[CCM_summary$cat=="pdo" | CCM_summary$cat=="npgo" | CCM_summary$cat=="upw" | CCM_summary$cat=="arc",]
abiotic_return_year_CCM <- abiotic_CCM[c(which(abiotic_CCM$rec==abiotic_CCM$offset)),]
abiotic_return_year_CCM$vargroup <- "return year"

abiotic_first_ocean_year_CCM <- abiotic_CCM[abiotic_CCM$offset==2,]
abiotic_first_ocean_year_CCM$vargroup <- "first ocean year"

#flow_CCM <- CCM_summary[CCM_summary$cat=="flow",]
#flow_CCM$vargroup <- "river conditions"

CCM <- rbind(harv_CCM, hatch_CCM, biotic_CCM, abiotic_first_ocean_year_CCM, abiotic_return_year_CCM)
#CCM <- CCM[CCM$level=="D_ESU" | CCM$level=="D_MFS" | CCM$level=="D_IMN" |CCM$level=="D_UPS",]

manual_color_codes <- read.csv("Data/csv_data/CORE_CCM_figure_color_codes.csv") #csv file containing the manual color codes and labels for plots 
     mcc <- manual_color_codes[,1:3]
    
unique_cat <- unique(CCM$cat) #for each unique putative causal variable category

for(i in 1:length(unique_cat)){
cat <- unique_cat[i]
Dp <- CCM[CCM$cat==cat,]     
Dp <- Dp[Dp$pval<=0.8,]

p1 <- ggplot(Dp) + 
    geom_point(aes(x=pval, y=rho, color=subcat, shape=tau)) +
    #geom_errorbar(aes(x=pval, y=rho, color=subcat, ymin=lower, ymax=upper), width=0.01) +
    scale_x_continuous(name=expression(paste("p-value terminal ", {rho}, " > starting ", {rho})), limits=c(0, 0.4), breaks=seq(0,0.4,0.1), labels=c("0", "0.1", "0.2", "0.3", "0.4")) +
    scale_y_continuous(name=expression(paste("Terminal cross-mapping correlation, ", {rho})), limits=c(-0.2, 0.8), breaks=seq(-0.2,0.8,0.2)) +
    geom_vline(aes(xintercept=0.05), colour='#999999') +
    theme_bw() + 
    guides(col = guide_legend(ncol=1)) +
    labs(title= paste("CCM - ", cat,  Dp$vargroup[1])) + 
    #scale_color_manual(values = mcc[,1], name="subcat", breaks = mcc[,2], labels = mcc[,3]) +
    facet_grid(cat*vargroup*rec~level) +
       theme(strip.background = element_blank(), strip.placement = "outside")
print(p1)
ggsave(filename = paste("Output/Figures/3_CCM/Multispatial/", level, "_and_smaller_clusters_", cat, ".pdf", sep=""), plot = p1, width = 10, height = 7, units = "in") 
}




```




#Data explorations
```{R}
rm(list=ls()) 
level="ESU"
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn4.Rdata", sep=""))
CCM_4 <- CCM_summary[-1,]
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn5.Rdata", sep=""))
CCM_5 <- CCM_summary[-1,]
ESU <- rbind(CCM_4, CCM_5)
ESU <- ESU[ESU$level!="MFS" & ESU$level!="UPS" & ESU$level!="IMN",]

level="MFS"
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn4.Rdata", sep=""))
CCM_4 <- CCM_summary[-1,]
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn5.Rdata", sep=""))
CCM_5 <- CCM_summary[-1,]
MFS <- rbind(CCM_4, CCM_5)

level="IMN"
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn4.Rdata", sep=""))
CCM_4 <- CCM_summary[-1,]
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn5.Rdata", sep=""))
CCM_5 <- CCM_summary[-1,]
IMN <- rbind(CCM_4, CCM_5)

level="UPS"
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn4.Rdata", sep=""))
CCM_4 <- CCM_summary[-1,]
load(file = paste("Output/Rdata/3_CCM/multispatial/3_multispatial_results_", level,"_and_smaller_clusters_recspn5.Rdata", sep=""))
CCM_5 <- CCM_summary[-1,]
UPS <- rbind(CCM_4, CCM_5)

level="stock"
load(file = paste("Output/Rdata/3_CCM/stock_level/3_stock_results_recspn4.Rdata", sep=""))
CCM_4 <- stock_CCM_summary[-1,]
load(file = paste("Output/Rdata/3_CCM/stock_level/3_stock_results_recspn5.Rdata", sep=""))
CCM_5 <- stock_CCM_summary[-1,]
Stock <- rbind(CCM_4, CCM_5)
row.names(Stock) <- NULL
colnames(Stock)[colnames(Stock) == 'stock'] <- 'level'

CCM <- rbind(ESU,MFS,IMN,UPS)
CCM <- CCM[,c(-1, -3, -4, -5, -6, -12, -13)]
row.names(CCM) <- NULL
CCM <- CCM[c("level", "response_var", "causal_var", "cat", "subcat", "offset", "E", "tau", "rho", "pval")]
CCM <- rbind(Stock,CCM)

rm(CCM_4, CCM_5, CCM_summary, ESU, MFS, IMN, UPS, level, Stock, stock_CCM_summary)

CCM$rec <- NA
CCM$rec[CCM$response_var=="salm.recspn4n.0"] <- "4yo"
CCM$rec[CCM$response_var=="salm.recspn5n.0"] <- "5yo"

CCM <- CCM[CCM$pval<=0.1,]

CCM$rho <- as.numeric(CCM$rho)
CCM$pval <- as.numeric(CCM$pval)

CCM$leveltype <- "Stock"
CCM$leveltype[CCM$level =="MFS" |CCM$level =="UPS" | CCM$level =="IMN"] <- "MPGs"
CCM$leveltype[CCM$level =="D4_1" |CCM$level =="D4_2" | CCM$level =="D4_3"| CCM$level =="D4_4"| CCM$level =="D4_5"] <- "ESU heirarchical"
CCM$leveltype[CCM$level =="MFS_1" |CCM$level =="MFS_2" | CCM$level =="IMN_1"| CCM$level =="IMN_2" | CCM$level =="UPS_1"| CCM$level =="UPS_2"| CCM$level =="UPS_3"] <- "MPGs heirarchical"
CCM$leveltype[CCM$level =="ESU"] <- "ESU"

#only include the tau for each variable that optimizes rho
CCM <- CCM %>%
  group_by(level, leveltype, response_var, rec, causal_var, cat, subcat, offset, E) %>%
  summarize(max_rho = max(rho, na.rm = TRUE))

#only include the offset for each variable that optimizes rho
CCM <- CCM %>%
  group_by(level, leveltype, response_var, rec, cat, subcat, E) %>%
  summarize(max_rho = max(max_rho, na.rm = TRUE))


#plot as treemaps

#Whole ESU and MPG
CCMt <- CCM[CCM$leveltype!="Stock",]
          rec <- CCMt$rec
          leveltype <- CCMt$leveltype
          value <- as.numeric(CCMt$max_rho)
    data <- data.frame(rec,leveltype,value)
    
    p <- treemap(data,
                index=c("rec","leveltype"),
                vSize="value",
                type="index",
                palette = "Set2",
                bg.labels=c("white"),
                title="Comparison of different stock groupings",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     

    
    
    
    
#Only MPG grouping of stocks for 5 and 4 year old separately
    
    MPGh4 <- CCM[CCM$leveltype=="MPGs" & CCM$rec=="4yo",]
          level <- MPGh4$level
          cat <- MPGh4$cat
          subcat <- MPGh4$subcat
          value <- MPGh4$max_rho
    data <- data.frame(level,cat,subcat,value)
    p <- treemap(data,
                index=c("level","cat", "subcat"),
                vSize="value",
                type="index",
                palette = "Set2",
                bg.labels=c("white"),
                title="MPG  grouping of 4yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
    MPGh5 <- CCM[CCM$leveltype=="MPGs" & CCM$rec=="5yo",]
          level <- MPGh5$level
          cat <- MPGh5$cat
          subcat <- MPGh5$subcat
          value <- MPGh5$max_rho
    data <- data.frame(level,cat,subcat,value)
    p <- treemap(data,
                index=c("level","cat", "subcat"),
                vSize="value",
                type="index",
                palette = "Set2",
                bg.labels=c("white"),
                title="MPG grouping of 5yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
  
     
 #cats and subcats for each level of each MPG
    levels <- c("MFS", "IMN", "UPS")
    recs <- c("4yo", "5yo")

    for(l in 1:length(levels)){
          level <- levels[l]      
          
          for(k in 1:2){
            rec <- recs[k]
            
            D <- CCM[CCM$level==level,]
            D <- D[D$rec==rec,]
            
              if (nrow(D) == 0){
              next
              }
            
                cat <- D$cat
                subcat <- D$causal_var
                value <- D$max_rho
                data <- data.frame(cat,subcat,value)
                
              
                treemap(data,
                            index=c("cat","subcat"),
                            vSize="value",
                            type="index",
                            palette = "-RdYlBu",
                            title=paste("Significant causal variables in ", level, " for ", rec, sep=""),
                            align.labels=list(
                              c("center", "top"), 
                              c("left", "bottom")
                            )  
                          )  
                
          }
    }
     
#Only for individual stocks
    Stock4 <- CCM[CCM$leveltype=="Stock" & CCM$rec=="4yo",]
          level <- Stock4$level
          cat <- Stock4$cat
          subcat <- Stock4$subcat
          value <- Stock4$max_rho
    data <- data.frame(level,cat,subcat,value)
    
    p <- treemap(data,
                index=c("level","cat"),
                vSize="value",
                type="index",
                palette = "-RdYlBu",
                bg.labels=c("white"),
                title="Stock level CCM of 4yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
    
    Stock5 <- CCM[CCM$leveltype=="Stock" & CCM$rec=="5yo",]
          level <- Stock5$level
          cat <- Stock5$cat
          subcat <- Stock5$subcat
          value <- Stock5$max_rho
    data <- data.frame(level,cat,subcat,value)
    
    p <- treemap(data,
                index=c("level","cat"),
                vSize="value",
                type="index",
                palette = "-RdYlBu",
                bg.labels=c("white"),
                title="Stock level CCM of 5yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
     
```




```{R}
    
#Only MPG heirarchical grouping of stocks for 5 and 4 year old separately
    
    MPGh4 <- CCM[CCM$leveltype=="MPGs heirarchical" & CCM$rec=="4yo",]
          level <- MPGh4$level
          cat <- MPGh4$cat
          subcat <- MPGh4$subcat
          value <- MPGh4$rho
    data <- data.frame(level,cat,subcat,value)
    
    p <- treemap(data,
                index=c("level","cat"),
                vSize="value",
                type="index",
                palette = "Set2",
                bg.labels=c("white"),
                title="MPG heirarchical grouping of 4yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
    
    MPGh5 <- CCM[CCM$leveltype=="MPGs heirarchical" & CCM$rec=="5yo",]
          level <- MPGh5$level
          cat <- MPGh5$cat
          subcat <- MPGh5$subcat
          value <- MPGh5$rho
    data <- data.frame(level,cat,subcat,value)
    
    p <- treemap(data,
                index=c("level","cat"),
                vSize="value",
                type="index",
                palette = "Set2",
                bg.labels=c("white"),
                title="MPG heirarchical grouping of 5yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
  
     
 #cats and subcats for each level of each MPG
    levels <- c("MFS_1", "MFS_2", "IMN_1", "IMN_2", "UPS_1", "UPS_2", "UPS_3")
    recs <- c("4yo", "5yo")

    for(l in 1:length(levels)){
          level <- levels[l]      
          
          for(k in 1:2){
            rec <- recs[k]
            
            D <- CCM[CCM$level==level,]
            D <- D[D$rec==rec,]
            
              if (nrow(D) == 0){
              next
              }
            
                cat <- D$cat
                subcat <- D$subcat
                value <- D$rho
                data <- data.frame(cat,subcat,value)
                
              
                treemap(data,
                            index=c("cat","subcat"),
                            vSize="value",
                            type="index",
                            palette = "Set2",
                            title=paste("Significant causal variables in ", level, " for ", rec, sep=""),
                            align.labels=list(
                              c("center", "top"), 
                              c("left", "bottom")
                            )  
                          )  
                
          }
      }
        
    
#Only for individual stocks
    Stock4 <- CCM[CCM$leveltype=="Stock" & CCM$rec=="4yo",]
          level <- Stock4$level
          cat <- Stock4$cat
          subcat <- Stock4$subcat
          value <- Stock4$rho
    data <- data.frame(level,cat,subcat,value)
    
    p <- treemap(data,
                index=c("level","cat"),
                vSize="value",
                type="index",
                palette = "Set2",
                bg.labels=c("white"),
                title="Stock level grouping of 4yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
    
    Stock5 <- CCM[CCM$leveltype=="Stock" & CCM$rec=="5yo",]
          level <- Stock5$level
          cat <- Stock5$cat
          subcat <- Stock5$subcat
          value <- Stock5$rho
    data <- data.frame(level,cat,subcat,value)
    
    p <- treemap(data,
                index=c("level","cat"),
                vSize="value",
                type="index",
                palette = "Set2",
                bg.labels=c("white"),
                title="Stock level grouping of 5yo recruits per spawner",
                align.labels=list(
                  c("center", "top"), 
                  c("left", "bottom")
                )  
              )     
  
      
    
          
```
