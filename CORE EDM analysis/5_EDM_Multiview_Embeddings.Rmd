---
title: "5_EDM_Multiview_Embeddings"
author: "Alison Iles"
date: "12/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(ggplot2)
library(rEDM)
library(plyr)
library(reshape)
library(stringr)
library(tidyr)
```

#Multiview Embedding
The generality of Taken’s Theorem means that in situations with multivariate time series, there
can often be many different, valid attractor reconstructions. As described in (Ye and Sugihara
2016), combining these different models can result in improved forecasts.

Multiview() operates by constructing all possible embeddings of dimension E, with
lag up to max_lag (and excluding embeddings that don’t have at least one coordinate with 0
time lag). These embeddings are ranked by forecast skill (rho) over the lib portion of the
data. The individual forecasts for the top k embeddings are then averaged together.

```{R}
# determine the best univariate embedding dimension and theta for each target variable in each MPG

load("Data/Rdata/block_data.Rdata")  

mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 

 best_E <- matrix(NA, nrow = 4, ncol = 2) # Save the optimal embedding dimension for each target variable
    colnames(best_E) <- c("rec4_E", "rec5_E") 
 best_theta <- matrix(NA, nrow = 4, ncol = 2) # Save the optimal theta for each target variable
   colnames(best_theta) <- c("rec4_theta", "rec5_theta")
     
    i <- 1
for(u in c(1,3,4,5)){#)){ #,3,4,5)){# #For each MPG except Lower Snake
    data <- block_data[c(mpg==u)]
    mpgname <- as.character(data[[1]]$mpg[1])
    
    # concatenate the time series of the different stocks in the MPG together
    keys <-c(names(data[[1]]))
    merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
    merged_data <- as.data.frame(merged_data)
    valid <-  is.finite(merged_data$rec4_n)
    block <- merged_data[valid,]  
    
    # list the begin and end points of each stock and the break points within stocks
    lib <- matrix(NA, nrow = length(which(diff(block$year)!=1))+1, ncol = 2)
            lib[,1] <- c(1, which(diff(block$year)!=1)+1)
            lib[,2] <- c(which(diff(block$year)!=1), nrow(block))
            
            
 
    #  for each target variable 
    target_var <- c("rec4_n", "rec5_n")
        for(tv in 1:2){
          
          # determine the best univariate embedding dimension and theta
          data_target <- as.matrix(cbind(block$year, block[target_var[tv]]))
          rownames(data_target) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
          simplex_output <- simplex(data_target, E = 1:8, silent = TRUE)
          best_E[i,tv] <- min(simplex_output$E[simplex_output$rho>max(simplex_output$rho)-sd(simplex_output$rho)]) #choose the smallest E whose rho is within 1 stdv of the maximum rho)
          smap_output <- s_map(data_target, lib=lib, pred=lib, E=best_E[i,tv]) 
          theta <- smap_output$theta[which.max(smap_output$rho)] 
          best_theta[i,tv] <- smap_output$theta[which.max(smap_output$rho)] 
  
# MVE    
          # determine which library variables to include from the CCM analysis    
          ccm <- readRDS(paste("Output/Rdata/3_CCM/3_CCM_multivar_MPG_",mpgname,".RDS", sep = ""))
          ccm <- ccm %>% filter(library==target_var[tv]) 
          
          ccm <- ddply(ccm, .(cat, offset), subset, rho==max(rho)) #Keep the variable with the maximum rho in each category*offset.
          ccm <- ccm[ccm$rho>(ccm$`95p_crit`),] #only keep variables whose CCM rho is greater than the critical value
          #remove specific category*offset combinations
          #Third year river and hatchery variables
          ccm<-ccm[!(ccm$cat=='flow' & ccm$offset==3),] 
          
          ccm<-ccm[!(ccm$cat=='hatch' & ccm$offset==3),] 
          #remove either fourth year (if rec_5), or fifth year (if rec4) river and hatchery variables
          a <- c(4,5) 
          ccm<-ccm[!(ccm$cat=='flow' & ccm$offset==(subset(a,a!=tv+3))),] 
          ccm<-ccm[!(ccm$cat=='hatch' & ccm$offset==(subset(a,a!=tv+3))),] 
          #remove offsets greater than return year 
          ccm <- ccm[ccm$offset<=(tv+3),]
          
          chosen_vars <- ccm$target

# run the multiview embedding
          MVE_block <- as.matrix(cbind(block["year"],block[target_var[tv]], block["eff_n"], block[chosen_vars]))  
          rownames(MVE_block) <- NULL #remove rownames to supress error 
          
          
          
#trouble shooting the MVE code:          
          
          num_vars <- NCOL(MVE_block)
          num_vars <- num_vars - 1 #because first col is time
          max_lag <-3
          E <- 3
          lagged_block <- make_block(MVE_block[, 2:NCOL(MVE_block)])#, max_lag = max_lag,t = MVE_block[, 1], lib = lib, tau = tau,restrict_to_lib = FALSE)
          
          embeddings_list <- t(combn(num_vars * max_lag, E, simplify = TRUE))
          valid_embeddings_idx <- apply(embeddings_list %% max_lag, 1, 
                                  function(x) {1 %in% x}) #Attempts to exclude embeddings without at least one coordinate with 0 time lag! I don't think this is working properly because when max-lag is set to zero or one it doesn't work. 
          embeddings_list <- embeddings_list[valid_embeddings_idx, ]
          my_embeddings <- lapply(seq_len(NROW(embeddings_list)),
                            function(i) {embeddings_list[i, ]})
          
          
          
          MVE_mine <- MVE_function(MVE_block, lib = lib, pred = lib, E = best_E[i,tv], max_lag = 1, k = "sqrt", target_column = target_var[tv], stats_only = FALSE, save_lagged_block = TRUE, first_column_time = TRUE, silent = FALSE)        
          
           MVE_orig <- multiview(MVE_block, lib = lib, pred = lib, E = best_E[i,tv], max_lag = 1, k = "sqrt", target_column = target_var[tv], stats_only = FALSE, save_lagged_block = TRUE, first_column_time = TRUE, silent = FALSE)# `k`  = 'sqrt' uses floor(sqrt(m)), where m is the number of embeddings
              # 'lagged_block' gives the block that includes lags constructed for multiview embedding
              # 'embeddings' gives the list of the embeddings whose predictions were averaged together for each model.
        
          #save(MVE, theta, file = paste("Output/Rdata/5_MVE/5_MVE_",mpgname,"_",target_var[tv],".RData", sep = ""))
        }
    
    i <- i+1 
}

lagged_block <- make_block(MVE_block[, 2:NCOL(MVE_block)], max_lag = 1, t = MVE_block[, 1], lib = lib, tau = 1, restrict_to_lib = FALSE)
    
    
      
MVE_lagged_block <- MVE$lagged_block[[1]]
MVE_var_list <- colnames(MVE_lagged_block)
MVE_k_embeddings <- MVE$embeddings[[1]]
MVE_k_embeddingsnames <- matrix(NA, nrow = length(MVE_k_embeddings), ncol = MVE$E)
for(i in 1:length(MVE_k_embeddings)) { 
      MVE_k_embeddingsnames[i,] <-  MVE_var_list[unlist(MVE_k_embeddings[i])+1]
}


x <- melt(MVE) 
count(x$value)

```


#Multiview Embedding test code
```{R}
data("block_3sp")
testblock <- block_3sp[, c(2, 5, 8)] # use only the unlagged time series
testlib <- c(1, floor(NROW(block_3sp)/2))
testpred <- c(floor(NROW(block_3sp)/2) + 1, NROW(block_3sp))

testMVE <- multiview(testblock, lib = testlib, pred = testpred, E = 2, max_lag =2,
k = "all", target_column = 1, stats_only = FALSE, save_lagged_block =TRUE, silent = TRUE)

testMVE_lagged_block <- testMVE$lagged_block[[1]]
testMVE_var_list <- colnames(testMVE_lagged_block)
testMVE_k_embeddings <- testMVE$embeddings[[1]]
testMVE_k_embeddingsnames <- matrix(NA, nrow = length(testMVE_k_embeddings), ncol = testMVE$E)
for(i in 1:length(testMVE_k_embeddings)) { 
      testMVE_k_embeddingsnames[i,] <-  testMVE_var_list[unlist(testMVE_k_embeddings[i])+1]
}

#Notes:
# Embeddings do not have to include the target variable
```




#Figure: MVE, observed vs predicted
```{R}
# plot of observed vs predicted for the multiview embeddings
d <- MVE$model_output[[1]]

p3 <- ggplot() +
    geom_point(data=d, aes(x=time, y=obs, color="observed")) +
    geom_point(data=d, aes(x=time, y=pred, color="predicted")) +
    labs( subtitle = "Observed 4 year old recruits vs predicted", x="time", y="4 year old recruits (normalized)", color="Data") +
    theme_bw() 

print(p3)
```


#S-map Coefficients
Calculate interaction strengths from the top k multiview embeddings.

As described in (Deyle et al. 2016), the S-map coefficients from the appropriate multivariate embedding can be interpreted as dynamic, time-varying interaction strengths. The smap_coefficients column of the block_lnlp output is a list-column with the data.frames for the S-map coefficients in the first element of that list. The result is a data.frame with a row for each prediction and a columns for each of the predictor variables plus a constant.

```{R}
load("Data/Rdata/block_data.Rdata")  

mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 

k <- 1
u <- 1
tv <- 1

for(u in c(4)){  #For each MPG except Lower Snake 1,3,4,5
  data <- block_data[c(mpg==u)] 
  mpgname <- as.character(data[[1]]$mpg[1])
    
  # concatenate the time series of the different stocks in the MPG together
  keys <-c(names(data[[1]]))
  merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
  merged_data <- as.data.frame(merged_data)
  valid <-  is.finite(merged_data$rec_n) & is.finite(merged_data$eff_n)
  block <- merged_data[valid,]  
    
  # list the begin and end points of each stock and the break points within stocks
  lib <- matrix(NA, nrow = length(which(diff(block$year)!=1))+1, ncol = 2)
      lib[,1] <- c(1, which(diff(block$year)!=1)+1)
      lib[,2] <- c(which(diff(block$year)!=1), nrow(block))
 
            #  for each target variable 
            target_var <- c("rec4_n", "rec5_n")
            for(tv in 1:length(target_var)){
            load(paste("Output/Rdata/5_MVE/5_MVE_",mpgname,"_",target_var[tv],".RData", sep = ""))
            MVE_laggedblock <- MVE$lagged_block[[1]]
            MVE_embeddings <- MVE$embeddings[[1]]

            
           # for each embedding, use smaps to calculate the coefficients over time
                  smapcoeffs = list()
                  for(i in 1:NROW(MVE_embeddings)) {   
                  smapcols <- MVE_embeddings[[i]]+1
                  smapdata <- MVE_laggedblock[,smapcols]
                  smap <- block_lnlp(smapdata, lib=lib, pred=lib, method="s-map", target_column = 1, stats_only = FALSE, theta = theta, save_smap_coefficients = TRUE, silent=TRUE)
                  a <- data.frame(smap$smap_coefficients[[1]])
                  colnames(a) <- paste(i, c(names(smapdata),"constant"))
                  smapcoeffs[[i]] <- a
                  }
            
            #convert large smap coefficients list into plottable data frame
            d = do.call(cbind, smapcoeffs)  
            d <- cbind(block$year, d)
            colnames(d)[1] <- c("yr")
            d <- gather(d, key, coeff, -yr)  #create long data for plotting
            d <- separate(d, key, into=c("model","var"), sep = " ")  #add columns for model number, variable
            d <- d %>% filter(!grepl('constant', var))  #remove coefficients for constants
            # rename some of the variables
            d$var <- gsub('rec4_n', 'rec4', d$var) 
            d$var <- gsub('rec5_n', 'rec5', d$var)
            d$var <- gsub('pdo_win_4', 'pdowin4', d$var)
            d$var <- gsub('up48_oct_4', 'up48oct4', d$var)
            d$var <- gsub("eff_n", 'eff', d$var)
            d$var <- gsub('npgo_yr_4', 'npgo4', d$var)
           
            
            d <- separate(d, var, into=c("var","offset"), extra = "merge", sep = "_")  
            d$offset <- d$offset %>% replace_na(0) #replace NAs for the target variable and offset values
            
            # For each variable, plot the changing coefficients over time from different mutivariate embeddings
            # loop through the different chosen variables
            chosen_vars <- unique(d$var)
            for(i in 1:NROW(chosen_vars)) {  
            df <- filter(d,var==chosen_vars[i])
            p <- ggplot(df, aes(x=yr, y=coeff, group = interaction(model, offset), colour = offset)) +
                geom_line() +
                theme_bw() + 
                labs( subtitle = paste("Effect of", chosen_vars[i], "on", target_var[tv], "across top k multiview embeddings", sep = " "), x="year", y="interaction coefficient") 
                #facet_grid(cat~pod)  # rows are categories, columns are pods
            print(p)
            ggsave(filename = paste("Output/Figures/5_MVE/coeff_", chosen_vars[i], "_on_" ,target_var[tv], "_", mpgname, ".pdf", sep = ""), plot = p, width = 7, height = 9.5, units = "in")  # saves the last plot
k <- k+1
              }
        }
}
```

