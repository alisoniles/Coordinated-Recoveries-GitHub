---
title: "5_EDM_Multiview_Embeddings"
author: "Alison Iles"
date: "12/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(ggplot2)
library(rEDM)
library(plyr)
library(reshape)
library(stringr)
library(tidyr)
```

#Multiview Embedding
The generality of Taken’s Theorem means that in situations with multivariate time series, there
can often be many different, valid attractor reconstructions. As described in (Ye and Sugihara
2016), combining these different models can result in improved forecasts.

Multiview() operates by constructing all possible embeddings of dimension E, with
lag up to max_lag (and excluding embeddings that don’t have at least one coordinate with 0
time lag). These embeddings are ranked by forecast skill (rho) over the lib portion of the
data. The individual forecasts for the top k embeddings are then averaged together.

The multiview() function in rEDM package excludes embeddings without at least one coordinate with 0 time lag. This isn't working properly because when max-lag is set one and all variables are 0 lag, it returns that none of the embeddings are valid but they all should be. I'm going to write my own multiview function below because the number of effective spawners with zero lag will be included in all embeddings. 


```{R}
rm(list=ls()) 
load("Data/Rdata/block_data.Rdata")  

mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 

    i <- 1
    u <- 1
    tv <- 1

for(u in c(1,3,4,5)){ # for each MPG except Lower Snake, 2
    data <- block_data[c(mpg==u)]
    mpgname <- as.character(data[[1]]$mpg[1])
    
target_var <- c("rec_n","rec3_n", "rec4_n", "rec5_n") 
    best_E_T <- matrix(NA, nrow = length(target_var), ncol = 3) # Save the optimal embedding dimension for each target variable
          colnames(best_E_T) <- c("target","E", "theta")
          best_E_T[,1] <- t(target_var)    
 
for(tv in 1:length(target_var)){ # for each target variable in each MPG            

    # concatenate the time series of the different stocks in the MPG together
    keys <-c(names(data[[1]]))
    merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
    merged_data <- as.data.frame(merged_data)
    valid <- is.finite(eval(parse(text=paste('merged_data$',target_var[tv],sep="")))) 
    block <- merged_data[valid,]  
    
    # list the begin and end points of each stock and the break points within stocks
    lib <- matrix(NA, nrow = length(which(diff(block$year)!=1))+1, ncol = 2)
            lib[,1] <- c(1, which(diff(block$year)!=1)+1)
            lib[,2] <- c(which(diff(block$year)!=1), nrow(block))
            
    # determine the best univariate embedding dimension and theta for each target variable
    data_target <- as.matrix(cbind(block$year, block[target_var[tv]]))
          rownames(data_target) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
          simplex_output <- simplex(data_target, E = 1:8, silent = TRUE)
          # choose the smallest E whose rho is within 1 stdv of the maximum rho)
          best_E_T[tv,2] <-  min(simplex_output$E[simplex_output$rho>max(simplex_output$rho)-sd(simplex_output$rho)]) 
          smap_output <- s_map(data_target, lib=lib, pred=lib, E=as.numeric(best_E_T[tv,2])) 
          best_E_T[tv,3]  <- smap_output$theta[which.max(smap_output$rho)] 
  
    # determine which library variables to include from the CCM analysis    
    #ccm <- readRDS(paste("Output/Rdata/3_CCM/3_CCM_multivar_MPG_",mpgname,".RDS", sep = ""))
    ccm <- readRDS(paste("Output/Rdata/3_CCM/CCM_univariate_tp_ ",mpgname,".RDS", sep = ""))
          ccm <- ccm %>% filter(library==target_var[tv])
          ccm <- ccm[ccm$rho>(1*ccm$`95p_crit`),] #only keep variables whose CCM rho is greater than the critical value
          ccm <- ccm %>% filter(MannKendall==TRUE)
          #remove either river variables that don't match the return year of the target recruit age
          a <- c(3,4,5) 
          ccm<-ccm[!(ccm$cat=='flow' & (ccm$tp==(subset(a,a!=tv+2)[1]) | ccm$tp==(subset(a,a!=tv+2)[2]))), ] 
          #remove offsets greater than return year 
          ccm <- ccm[ccm$tp<=(tv+2),]
          #remove offsets less than brood year 
          ccm <- ccm[ccm$tp>=(0),]
          
# Multiview embedding - make multivariate embeddings of all possible combinations of the chosen variables from the CCM analysis. Include the target variable and the number of effective spawners in each embedding. 
          
          MVE_block <- as.matrix(cbind(block["year"], block[target_var[tv]], block["eff_n"], block[ccm$target]))  #The chosen predictor variables are the sames as the target variables from the CCM; Here they are the library vars
          rownames(MVE_block) <- NULL #remove rownames to supress error 
          
          num_vars <- length(ccm$target) #number of predictor variables
          max_lag <-1 #number of lags of each of the chosen_vars (set to 1 as we chose our own lags for each var)
          E <- as.numeric(max(3, best_E_T[tv,2])) #embedding dimension needs to be at least 3, since we are including the variable of interest and the number of effective spawners in each embedding. 
          lagged_block <- make_block(MVE_block[, 2:NCOL(MVE_block)], max_lag = max_lag)
          
          embeddings_list <- t(combn(num_vars * max_lag, E-2, simplify = TRUE))
          embeddings_list <- embeddings_list + 2 #to include eff-n and the target variable in all embeddings
          embeddings_list <- cbind(matrix(data=1,nrow=nrow(embeddings_list), ncol=1), matrix(data=2,nrow=nrow(embeddings_list), ncol=1), embeddings_list)
        
# make in-sample forecasts
     in_results <- block_lnlp(MVE_block, lib = lib, pred = lib, 
                              method = "simplex", 
                              columns = embeddings_list, tp=1,
                              target_column = 1, #target_var[tv],
                              stats_only = TRUE, first_column_time = TRUE)
     
     # rank embeddings
     num_embeddings <- NROW(in_results)
     in_sample_ranking <- order(in_results$rho, decreasing = TRUE)
     best_embeddings <- embeddings_list[in_sample_ranking,][1:floor(sqrt(num_embeddings)),]
               
# Save smap coefficients
     out_results <- block_lnlp(lagged_block, lib = lib, pred = lib, 
                               method = "s-map", 
                               columns = embeddings_list, tp=1, # could use only 'best_embeddings' here
                               target_column = 1,
                               theta = best_E_T[tv,3],
                               stats_only = FALSE, first_column_time = TRUE,
                               save_smap_coefficients = TRUE)
     
     smap_coeffs <- as.data.frame(MVE_block[,1])
     colnames(smap_coeffs) <- "year"
     for (k in 1:length(out_results)){ #for each embedding  
     smapcoeffs <- data.frame(out_results$smap_coefficients[[k]]) #extract the interaction coefficients for each variable over time
     embed_names <- colnames(lagged_block[embeddings_list[k,]+1])
     coeff_names <- sapply(embed_names,function(x) paste(k,"_", target_var[tv], "/", x, sep = ""))
     colnames(smapcoeffs) <- paste(c(coeff_names, "constant"))
     smap_coeffs <- cbind(smap_coeffs, smapcoeffs[,1:ncol(embeddings_list)])
     
     #coeff_mean <- sapply(smapcoeffs, mean, na.rm=TRUE) # calculate the mean of each coeff
     #coeff_var <-  diag(var(smapcoeffs, na.rm=TRUE)) # calculate the variance of each coeff.
     #tt <- t.test(smapcoeffs)
     #coeff_ttest <- sapply(smapcoeffs, t.test)
     
     }
     
#     save(MVE, theta, file = paste("Output/Rdata/5_MVE/5_MVE_",mpgname,"_",target_var[tv],".RData", sep = ""))

}
    
    i <- i+1 
}

lagged_block <- make_block(MVE_block[, 2:NCOL(MVE_block)], max_lag = 1, t = MVE_block[, 1], lib = lib, tau = 1, restrict_to_lib = FALSE)
    
MVE_lagged_block <- MVE$lagged_block[[1]]
MVE_var_list <- colnames(MVE_lagged_block)
MVE_k_embeddings <- MVE$embeddings[[1]]
MVE_k_embeddingsnames <- matrix(NA, nrow = length(MVE_k_embeddings), ncol = MVE$E)
for(i in 1:length(MVE_k_embeddings)) { 
      MVE_k_embeddingsnames[i,] <-  MVE_var_list[unlist(MVE_k_embeddings[i])+1]
}


x <- melt(MVE) 
count(x$value)

```


#Multiview Embedding

```{R}
data("block_3sp")
testblock <- block_3sp[, c(2, 5, 8)] # use only the unlagged time series
testlib <- c(1, floor(NROW(block_3sp)/2))
testpred <- c(floor(NROW(block_3sp)/2) + 1, NROW(block_3sp))

testMVE <- multiview(testblock, lib = testlib, pred = testpred, E = 2, max_lag =2,
k = "all", target_column = 1, stats_only = FALSE, save_lagged_block =TRUE, silent = TRUE)

testMVE_lagged_block <- testMVE$lagged_block[[1]]
testMVE_var_list <- colnames(testMVE_lagged_block)
testMVE_k_embeddings <- testMVE$embeddings[[1]]
testMVE_k_embeddingsnames <- matrix(NA, nrow = length(testMVE_k_embeddings), ncol = testMVE$E)
for(i in 1:length(testMVE_k_embeddings)) { 
      testMVE_k_embeddingsnames[i,] <-  testMVE_var_list[unlist(testMVE_k_embeddings[i])+1]
}

#Notes:
# Embeddings do not have to include the target variable
```




#Figure: MVE, observed vs predicted
```{R}
# plot of observed vs predicted for the multiview embeddings
d <- MVE$model_output[[1]]

p3 <- ggplot() +
    geom_point(data=d, aes(x=time, y=obs, color="observed")) +
    geom_point(data=d, aes(x=time, y=pred, color="predicted")) +
    labs( subtitle = "Observed 4 year old recruits vs predicted", x="time", y="4 year old recruits (normalized)", color="Data") +
    theme_bw() 

print(p3)
```


#S-map Coefficients
Calculate interaction strengths from the top k multiview embeddings.

As described in (Deyle et al. 2016), the S-map coefficients from the appropriate multivariate embedding can be interpreted as dynamic, time-varying interaction strengths. The smap_coefficients column of the block_lnlp output is a list-column with the data.frames for the S-map coefficients in the first element of that list. The result is a data.frame with a row for each prediction and columns for each of the predictor variables plus a constant.

```{R}
load("Data/Rdata/block_data.Rdata")  

mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 

k <- 1
u <- 1
tv <- 1

for(u in c(4)){  #For each MPG except Lower Snake 1,3,4,5
  data <- block_data[c(mpg==u)] 
  mpgname <- as.character(data[[1]]$mpg[1])
    
  # concatenate the time series of the different stocks in the MPG together
  keys <-c(names(data[[1]]))
  merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
  merged_data <- as.data.frame(merged_data)
  valid <-  is.finite(merged_data$rec_n) & is.finite(merged_data$eff_n)
  block <- merged_data[valid,]  
    
  # list the begin and end points of each stock and the break points within stocks
  lib <- matrix(NA, nrow = length(which(diff(block$year)!=1))+1, ncol = 2)
      lib[,1] <- c(1, which(diff(block$year)!=1)+1)
      lib[,2] <- c(which(diff(block$year)!=1), nrow(block))
 
            #  for each target variable 
            target_var <- c("rec4_n", "rec5_n")
            for(tv in 1:length(target_var)){
            load(paste("Output/Rdata/5_MVE/5_MVE_",mpgname,"_",target_var[tv],".RData", sep = ""))
            MVE_laggedblock <- MVE$lagged_block[[1]]
            MVE_embeddings <- MVE$embeddings[[1]]

            
           # for each embedding, use smaps to calculate the coefficients over time
                  smapcoeffs = list()
                  for(i in 1:NROW(MVE_embeddings)) {   
                  smapcols <- MVE_embeddings[[i]]+1
                  smapdata <- MVE_laggedblock[,smapcols]
                  smap <- block_lnlp(smapdata, lib=lib, pred=lib, method="s-map", target_column = 1, stats_only = FALSE, theta = theta, save_smap_coefficients = TRUE, silent=TRUE)
                  a <- data.frame(smap$smap_coefficients[[1]])
                  colnames(a) <- paste(i, c(names(smapdata),"constant"))
                  smapcoeffs[[i]] <- a
                  }
            
            #convert large smap coefficients list into plottable data frame
            d = do.call(cbind, smapcoeffs)  
            d <- cbind(block$year, d)
            colnames(d)[1] <- c("yr")
            d <- gather(d, key, coeff, -yr)  #create long data for plotting
            d <- separate(d, key, into=c("model","var"), sep = " ")  #add columns for model number, variable
            d <- d %>% filter(!grepl('constant', var))  #remove coefficients for constants
            # rename some of the variables
            d$var <- gsub('rec4_n', 'rec4', d$var) 
            d$var <- gsub('rec5_n', 'rec5', d$var)
            d$var <- gsub('pdo_win_4', 'pdowin4', d$var)
            d$var <- gsub('up48_oct_4', 'up48oct4', d$var)
            d$var <- gsub("eff_n", 'eff', d$var)
            d$var <- gsub('npgo_yr_4', 'npgo4', d$var)
           
            
            d <- separate(d, var, into=c("var","offset"), extra = "merge", sep = "_")  
            d$offset <- d$offset %>% replace_na(0) #replace NAs for the target variable and offset values
            
            # For each variable, plot the changing coefficients over time from different mutivariate embeddings
            # loop through the different chosen variables
            chosen_vars <- unique(d$var)
            for(i in 1:NROW(chosen_vars)) {  
            df <- filter(d,var==chosen_vars[i])
            p <- ggplot(df, aes(x=yr, y=coeff, group = interaction(model, offset), colour = offset)) +
                geom_line() +
                theme_bw() + 
                labs( subtitle = paste("Effect of", chosen_vars[i], "on", target_var[tv], "across top k multiview embeddings", sep = " "), x="year", y="interaction coefficient") 
                #facet_grid(cat~pod)  # rows are categories, columns are pods
            print(p)
            ggsave(filename = paste("Output/Figures/5_MVE/coeff_", chosen_vars[i], "_on_" ,target_var[tv], "_", mpgname, ".pdf", sep = ""), plot = p, width = 7, height = 9.5, units = "in")  # saves the last plot
k <- k+1
              }
        }
}
```

