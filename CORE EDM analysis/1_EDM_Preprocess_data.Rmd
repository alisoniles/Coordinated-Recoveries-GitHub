---
title: "1_EDM_Preprocess_data"
author: "Alison Iles"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#load the necessary packages. 
Note that the `echo = FALSE` parameter prevents printing of the R code.

```{r, echo=FALSE}
library(rEDM)
library(reshape2)
#library(rgl)
library(ggplot2)
library(gridExtra)
library(xtable)
library(rlist)
library(tidyr)
```

#load data
```{R}
data <- read.csv("Data/csv_data/SRSS_cohort_prelim.csv")
```

#normalize

```{R}
 # To focus on one stock to figure out what's going on use
#stock_df <- subset(data, stk == "Bear Valley Creek") 
 
# The original code normalized by cycle line. Chinook don't demonstrate a strong cycle line, so I changed the normalize_by_cycle_line function to normalize on a 1 year cycle 
    normalize_by_cycle_line <- function(ts)
{
    n <- length(ts)
    means <- rep.int(NA, times = 4) #replicate NA 4 times
    sds <- rep.int(NA, times = 4)
    mu <- rep.int(NA, times = n)
    sigma <- rep.int(NA, times = n)
    for(k in 1:1) #for each cycle line (every 4 years the population cycles in sockeye, I've changed it to 1 because there are no cycle lines for chinook)
    {
        index <- seq(from = k, to = n, by = 1) #changed by=4 to b=1.
        means[k] <- mean(ts[index], na.rm = TRUE) #mean of every 4th element of the time series
        sds[k] <- sd(ts[index], na.rm = TRUE) #standard dev.
        mu[index] <- means[k]
        sigma[index] <- sds[k]
    }
    ts <- (ts - mu) / sigma  #normalize by cycle line
    df <- data.frame(cbind(ts, mu, sigma))
    return(df)
    }
    
     preprocess_stock <- function(stock_df)
    {
        n <- NROW(stock_df)  #n is the number of observations for the stock
         
        stock_df$ret <- stock_df$rec3 + c(NA, stock_df$rec4[1:(n-1)]) + c(NA, NA, stock_df$rec5[1:(n-2)]) #+ c(NA, NA, NA, stock_df$rec6[1:(n-3)]) # age-3,4,5,and 6 fish (aligned to rec3) #total returns in a given year are calculated by adding 3 year old recruits plus 4 year old recruits from the previous brood year, plus 5 year olds from two years prior...etc. This value is aligned to the rec3 brood year, not the year they are actually returning together. 
       
        stock_df$rat <- stock_df$rec/stock_df$eff #ratio of recruits-per-spawner; the total recruits per spawner from a given brood year.
        stock_df$rat3 <- stock_df$rec3/stock_df$eff #ratio of 3 year old recruits-per-spawner from a given brood year.
        stock_df$rat4 <- stock_df$rec4/stock_df$eff #ratio of 4 year old recruits-per-spawner from a given brood year.
        stock_df$rat5 <- stock_df$rec5/stock_df$eff #ratio of 5 year old recruits-per-spawner from a given brood year.

        # Normalize on a 1 year cycle line (i.e. NO cycle line!)
        temp <- normalize_by_cycle_line(stock_df$eff)
        stock_df$eff_n <- temp$ts #normalized number of effective spawners
        stock_df$eff_mu <- temp$mu
        stock_df$eff_sigma <- temp$sigma
        
        temp <- normalize_by_cycle_line(stock_df$rec3)
        stock_df$rec3_n <- temp$ts #normalized 3 year old recruits
        stock_df$rec3_mu <- temp$mu
        stock_df$rec3_sigma <- temp$sigma
        
        temp <- normalize_by_cycle_line(stock_df$rec4)
        stock_df$rec4_n <- temp$ts #normalized 4 year old recruits
        stock_df$rec4_mu <- temp$mu
        stock_df$rec4_sigma <- temp$sigma

        temp <- normalize_by_cycle_line(stock_df$rec5)
        stock_df$rec5_n <- temp$ts #normalized 5 year old recruits
        stock_df$rec5_mu <- temp$mu
        stock_df$rec5_sigma <- temp$sigma
        
        temp <- normalize_by_cycle_line(stock_df$rec)
        stock_df$rec_n <- temp$ts #normalized total recruits
        stock_df$rec_mu <- temp$mu
        stock_df$rec_sigma <- temp$sigma
        
        temp <- normalize_by_cycle_line(stock_df$ret)
        stock_df$ret_n <- temp$ts #normalized returns
        stock_df$ret_mu <- temp$mu
        stock_df$ret_sigma <- temp$sigma

        temp <- normalize_by_cycle_line(stock_df$rat)
        stock_df$rat_n <- temp$ts #normalized returns
        stock_df$rat_mu <- temp$mu
        stock_df$rat_sigma <- temp$sigma
        
        temp <- normalize_by_cycle_line(stock_df$rat3)
        stock_df$rat3_n <- temp$ts #normalized returns
        stock_df$rat3_mu <- temp$mu
        stock_df$rat3_sigma <- temp$sigma
        
        temp <- normalize_by_cycle_line(stock_df$rat4)
        stock_df$rat4_n <- temp$ts #normalized returns
        stock_df$rat4_mu <- temp$mu
        stock_df$rat4_sigma <- temp$sigma
        
        temp <- normalize_by_cycle_line(stock_df$rat5)
        stock_df$rat5_n <- temp$ts #normalized returns
        stock_df$rat5_mu <- temp$mu
        stock_df$rat5_sigma <- temp$sigma
        
        return(stock_df)
    }   

     
# filter stocks we don't want
stock_data <- split(data, data$stk)    
stock_data <- lapply(stock_data, preprocess_stock) 
# lapply returns a list of the same length as X, each element of which is the result of applying FUN to the corresponding element of X.
```

#load environmental data and data for other species

```{R}
env_data <- read.csv("Data/csv_data/SRSS_env_prelim.csv")
sealion_data <- read.csv("Data/csv_data/sealion.csv")
SRKW_data <- read.csv("Data/csv_data/SRKW/SRKW.csv")


normalize <- function(block)
{
    if(NCOL(block) > 1)
    {
        n <- NROW(block)
        means <- sapply(block, mean, na.rm = TRUE)
        sds <- sapply(block, sd, na.rm = TRUE)
        return((block - matrix(rep(means, each = n), nrow = n)) / 
                   matrix(rep(sds, each = n), nrow = n))
    }
    else
        return((block - mean(block, na.rm = TRUE)) / sd(block, na.rm = TRUE))
}


make_block <- function(stock_df, env_data, sealion_data, SRKW_data)
    {
        pdo_names <- c("pdo_jan",	"pdo_feb",	"pdo_mar",	"pdo_apr",	"pdo_may",	"pdo_jun",	"pdo_jul",	"pdo_aug",	"pdo_sep",	"pdo_oct",	"pdo_nov",	"pdo_dec", "pdo_win") 
        pdo <- normalize(env_data[, pdo_names])
        upwelling_names <- c("up48_jan",	"up48_feb",	"up48_mar",	"up48_apr",	"up48_may",	"up48_jun",	"up48_jul",	"up48_aug",	"up48_sep",	"up48_oct",	"up48_nov",	"up48_dec")	
        upwelling <- normalize(env_data[, upwelling_names])
        npgo_names <- c("npgo_jan",	"npgo_feb",	"npgo_mar",	"npgo_apr",	"npgo_may",	"npgo_jun",	"npgo_jul",	"npgo_aug",	"npgo_sep",	"npgo_oct",	"npgo_nov",	"npgo_dec",	"npgo_yr")
        npgo <- normalize(env_data[, npgo_names])
        #sealion_names <- c("SL_pups", "SL_males")
        sealion_pups <- normalize(sealion_data[, "SL_pups"])
        sealion_males <- normalize(sealion_data[, "SL_males"])
        SRKW_names <- c( "SRKW_Jpod" ,     "SRKW_Kpod"  ,    "SRKW_Lpod"  ,    "SRKW_KLpods" ,   "SRKW_JKLpods" , 
 "SRKW_JKLdeaths", "SRKW_JKLbirths")
        SRKW <- normalize(SRKW_data[, SRKW_names]) 
        
        # line up environmental data
        for(i in 2:5) { # lag environmental data from 0 to 6 years after brood year. 
              desired_years <- stock_df$yr + i
              index_in_env_data <- match(desired_years, env_data$year)
              index_in_stock_df <- 1:length(desired_years)
        
              # lag upwelling
              upwelling_cols <- data.frame(matrix(NA, nrow = length(desired_years), ncol = NCOL(upwelling)))
              upwelling_cols[index_in_stock_df,] <- upwelling[index_in_env_data, ]
              m2 <- cbind(1,1:4)
              colnames <- paste(upwelling_names, i, sep = "_")
              stock_df[, colnames] <- upwelling_cols
              
              # lag PDO 
              pdo_cols <- data.frame(matrix(NA, nrow = length(desired_years), ncol = NCOL(pdo)))
              pdo_cols[index_in_stock_df,] <- pdo[index_in_env_data, ]
              colnames <- paste(pdo_names, i, sep = "_")
              stock_df[, colnames] <- pdo_cols
              
               # lag NPGO  
              npgo_cols <- data.frame(matrix(NA, nrow = length(desired_years), ncol = NCOL(npgo)))
              npgo_cols[index_in_stock_df,] <- npgo[index_in_env_data, ]
              colnames <- paste(npgo_names, i, sep = "_")
              stock_df[, colnames] <- npgo_cols
              }
        
        # line up sealion data
        for(i in 2:5) { # lag sealion data from 2 to 5 years after brood year - assuming sea lions eat smolts and returns
              desired_years <- stock_df$yr + i
              index_in_spp_data <- match(desired_years, sealion_data$Year)
              index_in_stock_df <- 1:length(desired_years)
              sl_cols <- data.frame(matrix(NA, nrow = length(desired_years), ncol = NCOL(sealion_males)))
              sl_cols[index_in_stock_df,] <- sealion_males[index_in_spp_data ]
              colnames <- paste("SL_males", i, sep = "_")
              stock_df[, colnames] <- sl_cols
        }
        for(i in 5:8) { # lag sealion pup data from 2 to 5 years after brood year plus 3 years as only 3+ year old sea lion males swim up to oregon
              desired_years <- stock_df$yr + i
              index_in_spp_data <- match(desired_years, sealion_data$Year)
              index_in_stock_df <- 1:length(desired_years)
              sl_cols <- data.frame(matrix(NA, nrow = length(desired_years), ncol = NCOL(sealion_pups)))
              sl_cols[index_in_stock_df,] <- sealion_pups[index_in_spp_data ]
              colnames <- paste("SL_pups", i, sep = "_")
              stock_df[, colnames] <- sl_cols
              }
        
        # line up orca data
        for(i in 3:5) { # lag orca data from 3 to 5 years after brood year - assuming orcas just eat the returning fish
              desired_years <- stock_df$yr + i
              index_in_spp_data <- match(desired_years, SRKW_data$Year)
              index_in_stock_df <- 1:length(desired_years)
                     
              orca_cols <- data.frame(matrix(NA, nrow = length(desired_years), ncol = NCOL(SRKW)))
              orca_cols[index_in_stock_df,] <- SRKW[index_in_spp_data, ]
              colnames <- paste(SRKW_names, i, sep = "_")
              stock_df[, colnames] <- orca_cols
              }
        
        
        return(stock_df)
    }

block_data <- lapply(stock_data, function(stock_df) {make_block(stock_df, env_data, sealion_data, SRKW_data)})

    
# save and return
    save(block_data, file = "Data/Rdata/block_data.Rdata")

```


