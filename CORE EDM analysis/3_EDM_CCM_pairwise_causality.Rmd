---
title: "3_EDM_CCM_pairwise_causality"
author: "Alison Iles"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#load the necessary packages. 
Note that the `echo = FALSE` parameter prevents printing of the R code.

```{r, echo=FALSE}
library(rEDM)
library(reshape2)
library(ggplot2)
library(viridis)
library(gridExtra)
library(xtable)
library(rlist)
library(Kendall) #for MannKendall test
library(psych) #for paired.r function
```


#Convergent Cross Mapping (CCM) with time delays
To test whether pairwise causality exists between the environmental variables and the spawner recruit relationship. Also to test all the lags for each environmental variable to figure out which is the best to use in the multivariate embeddings.

We tested all monthly values of PDO, Upwelling index (for both 45 and 48 degrees latitude) and NPGO, even though with have apriori knowledge of which months are likely the most important for salmon. 

block_lnlp uses multiple time series given as input to generate an attractor reconstruction, and then applies the simplex projection or s-map algorithm to make forecasts. This method generalizes the simplex and s_map routines, and allows for "mixed" embeddings, where multiple time series can be used as different dimensions of an attractor reconstruction.


```{r}

# determine the best embedding dimension to use first with simplex?
library(sm)
library(vioplot)


compute_ccm <- function()
{
    load("Data/Rdata/block_data.Rdata")
    env_vars <- c("up45_jan",	"up45_feb",	"up45_mar",	"up45_apr",	"up45_may",	"up45_jun",	"up45_jul",	"up45_aug",	"up45_sep",	"up45_oct",	"up45_nov",	"up45_dec",	"up48_jan",	"up48_feb",	"up48_mar",	"up48_apr",	"up48_may",	"up48_jun",	"up48_jul",	"up48_aug",	"up48_sep",	"up48_oct",	"up48_nov",	"up48_dec", "pdo_jan",	"pdo_feb",	"pdo_mar",	"pdo_apr",	"pdo_may",	"pdo_jun",	"pdo_jul",	"pdo_aug",	"pdo_sep",	"pdo_oct",	"pdo_nov",	"pdo_dec", "pdo_win", "npgo_jan",	"npgo_feb",	"npgo_mar",	"npgo_apr",	"npgo_may",	"npgo_jun",	"npgo_jul",	"npgo_aug",	"npgo_sep",	"npgo_oct",	"npgo_nov",	"npgo_dec",	"npgo_yr")
    ccm_table <- do.call(rbind, lapply(block_data, function(stock_df) 
         {
        valid <- is.finite(stock_df$rec5_n) & is.finite(stock_df$eff_n)
        block <- stock_df[valid,]
        
        ccm_rhos <- do.call(cbind, lapply(env_vars, function(env_var) {
            output <- block_lnlp(block, tp = 0, target_column = env_var, 
                                 columns = c("rec5_n", "eff_n"), silent = TRUE)
            return(output$rho)
        }))
        colnames(ccm_rhos) <- env_vars
        ccm_rhos <- cbind(N = sum(valid), ccm_rhos)
        return(ccm_rhos)
    }))
    rownames(ccm_table) <- names(block_data)
    saveRDS(ccm_table, file = "results_ccm.RDS")
    return()
}

print_ccm_table <- function()
{
    ccm_table <- data.frame(readRDS("results_ccm.RDS"))
    ccm_table <- cbind("N" = ccm_table$N,
                       "95% p" = tanh(qnorm(0.95, sd = 1/sqrt(ccm_table$N - 3))), 
                       ccm_table[,2:NCOL(ccm_table)])
    my_table <- xtable(ccm_table, digits = 3)
    print(my_table, type = "html", file = "Output/Tables/Table_S3.html")
    return(ccm_table)
}

compute_ccm()
print_ccm_table() # table S3 in Sockeye paper
```

```{R}
quartz()
vioplot(ccm_table[,3:14], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec"))
title("CCM of upwelling at 45 degrees")
```

```{R}
vioplot(ccm_table[,15:26], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec"), title("CCM of upwelling at 48 degrees"))

```
```{R}
vioplot(ccm_table[,27:39], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec",  "Win"), title("CCM of PDO"))

```

```{R}
vioplot(ccm_table[,40:52], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec", "Year"), title("CCM of NPGO"))

```

#Convergent cross-mapping test for the major population groups 

```{r}

compute_ccm_mpg <- function(data, name)
{
    #concatenate the time series of each variable together
        keys <-c(names(data[[1]]))
        merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
        merged_data <- as.data.frame(merged_data)
        valid <- is.finite(merged_data$rec4_n) & is.finite(merged_data$rec5_n) & is.finite(merged_data$eff_n)
        block <- merged_data[valid,]  
        
    #List in lib the begin and end points of each stock
        lib <- matrix(NA, nrow = length(which(diff(block$yr)!=1))+1, ncol = 2)
        lib[,1] <- c(1, which(diff(block$yr)!=1)+1)
        lib[,2] <- c(which(diff(block$yr)!=1), nrow(block))
        ## NOTE: library includes breaks between stocks AND non-continuous breaks within stocks
     
        env_vars <- c(names(data[[1]][28:77]))
  
        ccm_table <- do.call(cbind, lapply(env_vars, function(env_var) 
          {  output <- block_lnlp(block, lib, target_column = env_var, method = c("s-map"), theta = 2, tp=0, columns = c("rec4_n", "rec5_n", "eff_n"), save_smap_coefficients = TRUE)
            #For the tp parameter, the default value of 1 means that the program will predict the target variable 1 time step into the future (based on the row-structure of the input data). In some cases, the data may already be processed into a format where one wants to predict a different column that has already been aligned correctly. In that case, one can set tp = 0 when calling block_lnlp.
            return(output$rho)
        }))
        colnames(ccm_table) <- env_vars
        ccm_table <- cbind(N = sum(valid), ccm_table)
        rownames(ccm_table) <- name
        
        ccm_table <- as.data.frame(ccm_table)
        ccm_table <- cbind("N" = ccm_table$N,
                       "95% p" = tanh(qnorm(0.95, sd = 1/sqrt(ccm_table$N - 3))), 
                       ccm_table[,2:NCOL(ccm_table)])
        ccm_table <- xtable(ccm_table, digits = 3)

        saveRDS(ccm_table, file = paste("Output/Rdata/results_ccm_",name,".RDS", sep = "", collapse = NULL))
    
    return()
}

###--- nonlinear test for different major population groups
load("Data/Rdata/block_data.Rdata")  
mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
  
  for(u in c(1, 3, 4, 5)){
    data <- block_data[c(mpg==u)]
    name <- as.character(data[[1]]$mpg[1])
    compute_ccm_mpg(data, name)
  }

    ccm_table_I <- data.frame(readRDS("Output/Rdata/results_ccm_Imnaha.RDS"))
    ccm_table_MFS <- data.frame(readRDS("Output/Rdata/results_ccm_Middle Fork Salmon.RDS"))
    ccm_table_SFS <- data.frame(readRDS("Output/Rdata/results_ccm_South Fork Salmon.RDS"))
    ccm_table_US <- data.frame(readRDS("Output/Rdata/results_ccm_Upper Salmon.RDS"))
    
    ccm_table <- rbind(ccm_table_I, ccm_table_MFS, ccm_table_SFS, ccm_table_US)
    saveRDS(ccm_table, file = "Output/Rdata/results_ccm_mpg.RDS", compress = FALSE)
    
    print(ccm_table, type = "html", file = "Output/Tables/CCM_MPG.html")
```

#ccm
Setup the cross mapping runs we want to do:
```{R}
load("Data/Rdata/block_data.Rdata")  

mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 

normalize <- function(block)
{
    if(NCOL(block) > 1)
    {
        n <- NROW(block)
        means <- sapply(block, mean, na.rm = TRUE)
        sds <- sapply(block, sd, na.rm = TRUE)
        return((block - matrix(rep(means, each = n), nrow = n)) / 
                   matrix(rep(sds, each = n), nrow = n))
    }
    else
        return((block - mean(block, na.rm = TRUE)) / sd(block, na.rm = TRUE))
}
     

 
for(u in c(1:5)){   # for each mpg
    data <- block_data[c(mpg==u)]
    name <- as.character(data[[1]]$mpg[1])
  
    #concatenate the time series of each variable together
    keys <-c(names(data[[1]]))
    merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
    merged_data <- as.data.frame(merged_data)
    valid <- is.finite(merged_data$rec4_n) & is.finite(merged_data$rec5_n) & is.finite(merged_data$eff_n)
    block <- merged_data[valid,]  
    
    #List in lib the begin and end points of each stock and the break points within stocks
    lib <- matrix(NA, nrow = length(which(diff(block$yr)!=1))+1, ncol = 2)
    lib[,1] <- c(1, which(diff(block$yr)!=1)+1)
    lib[,2] <- c(which(diff(block$yr)!=1), nrow(block))

    #set up output table
    library_vars <- c("rec3_n", "rec4_n", "rec5_n", "eff_n")
    env_vars <- c("up45_jan",	"up45_feb",	"up45_mar",	"up45_apr",	"up45_may",	"up45_jun",	"up45_jul",	"up45_aug",	"up45_sep",	"up45_oct",	"up45_nov",	"up45_dec",	"up48_jan",	"up48_feb",	"up48_mar",	"up48_apr",	"up48_may",	"up48_jun",	"up48_jul",	"up48_aug",	"up48_sep",	"up48_oct",	"up48_nov",	"up48_dec", "pdo_jan",	"pdo_feb",	"pdo_mar",	"pdo_apr",	"pdo_may",	"pdo_jun",	"pdo_jul",	"pdo_aug",	"pdo_sep",	"pdo_oct",	"pdo_nov",	"pdo_dec", "pdo_win", "npgo_jan",	"npgo_feb",	"npgo_mar",	"npgo_apr",	"npgo_may",	"npgo_jun",	"npgo_jul",	"npgo_aug",	"npgo_sep",	"npgo_oct",	"npgo_nov",	"npgo_dec",	"npgo_yr")
    lags <- c(0,1,2,3,4,5,6)
    CCM_outputlist <- expand.grid(env_vars, library_vars, lags, stringsAsFactors = FALSE) 
    CCM_outputlist[,4] <- paste(CCM_outputlist[,1], CCM_outputlist[,3], sep = "_")
    CCM_outputlist[,5:10] <- matrix(NA, nrow = NROW(CCM_outputlist), ncol = 6)
    colnames( CCM_outputlist) <- c("env_fac","library","offset","target","target E","rho","95%CI lower","95%CI upper","MK test","FZ test")

    #Perform cross mappings:      
    libsize <- round(seq(NROW(block)/8, NROW(block), by = NROW(block)/8))
    for(i in c(1:NROW(CCM_outputlist)) ){  #c(1:100)
    
      library_var <- CCM_outputlist[i,2]
      target_var <- CCM_outputlist[i,4]
      env_factor <- CCM_outputlist[i,1]
      
          # determine the best univariate embedding dimension and theta for the target variables - use time series of environemtnal vars from 1957 to 2009+7(lags)=2016 for ALL lags, so all lags of the same environmental variable have the same E
            env_data <- read.csv("Data/csv_data/SRSS_env_prelim.csv")
            env_data <- env_data[ which(env_data$year>1956 & env_data$year<2017),] #select 1957 to 2016
            timeyr <- env_data[,1]
            env_data <- normalize(env_data[2:51]) #normalize
            data <- as.matrix(cbind(timeyr, env_data[env_factor]))
            simplex_output <- simplex(data, E = 1:12, silent = TRUE)
            CCM_outputlist[i,5] <- simplex_output$E[which.max(simplex_output$rho)] #Apply optimal E that maximizes rho to the following CCM...
    
          # CCM from library var to target var   
            data <- as.matrix(cbind(block$yr, block[library_var],block[target_var]))
            rownames(data) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
            xmap <-  ccm(data, lib = lib, E = CCM_outputlist[i,5], lib_column = library_var, target_column = target_var, lib_sizes = libsize, silent = TRUE)
    
    #for(v in c(1:NROW(target_vars))){output <- do.call(rbind, lapply(seq_len(NCOL(target_vars)), function(l) {block_lnlp(block, lib, columns = library_vars, target_column = target_vars[v,l], method = c("simplex"), tp = 0, silent = TRUE)}
                
    # Calculate the median, maximum, and 1st & 3rd quantile of rho
            rho_quant=as.matrix(aggregate(xmap[,c('rho')],by = list(as.factor(xmap$lib_size)), quantile, na.rm = TRUE)[,'x'])
            rho_quant <- rho_quant[complete.cases(rho_quant*0),1:5] #removes rows with inf values
            CCM_outputlist[i,6] <- signif(rho_quant[dim(rho_quant)[1],3],2) #save the cross map skill at max library size (50th percentile)
            CCM_outputlist[i,7:8] <- r.con(rho_quant[dim(rho_quant)[1],3], libsize[dim(rho_quant)[1]], p=.95, twotailed=FALSE) # Test if rho is significantly different from 0 at p=0.05 level (done for Sockey in Ye et al. 2015)
            
            #Test for monotonic trend in a time series z[t] based on the Kendall rank correlation of z[t] and t. 
            #Here the median, maximum, and 1st & 3rd quantiles are tested, all need to be <0.05.
            MK <- apply(rho_quant[,2:5],2,MannKendall) 
            CCM_outputlist[i,9] <- (MK$`25%`[[2]]<0.05 & MK$`50%`[[2]]<0.05 & MK$`75%`[[2]]<0.05 & MK$`100%`[[2]]<0.05)
            
            # Transforms the rho at the min library and max library length to a normally distributed Fisher's z value
            # Tests that the max library z is significantly higher than the begining. 
            # Independent correlations, different sample sizes. Our small sample sizes are a disadvantage here.
            FZ <- paired.r(rho_quant[1,3],rho_quant[dim(rho_quant)[1],3], NULL, libsize[1], libsize[dim(rho_quant)[1]], twotailed=FALSE)
            CCM_outputlist[i,10] <- FZ$p
      }

     saveRDS(CCM_outputlist, file = paste("Output/Rdata/CCM ",name,".RDS", sep = ""), compress = FALSE)

# figure
# sort output table by environmental var, then by library var, then by lag
d <-  CCM_outputlist[order(CCM_outputlist$offset),]
d <-  d[order(d$library),]
d <-  d[order(d$env_fac),]
d[,11] <- paste(d$library, 'xmap', d$env_fac)
colnames(d)[11] <- "xmap"
d <- separate(d,env_fac, into=c("env_fac","month"), sep = "_")

p1 <- ggplot(d, aes(x=offset, y=rho)) +
    geom_line(aes(col=month)) +
    geom_point(aes(col=month, shape=d$`MK test`)) +
    theme_bw() + 
    labs(title=name, x="Offset", y="Rho") +  
    scale_color_manual(values = c("jan"='#800000', "feb"='#e6194b', "mar"='#f58231', "apr"='#ffe119', "may"='#bfef45', "jun"='#3cb44b', "jul"='#469990', "aug"='#42d4f4', "sep"='#4363d8', "oct"='#000075', "nov"='#911eb4', "dec"='#f032e6', "win"='#a9a9a9', "yr"='#a9a9a9'), name="Time series", breaks = c("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec", "win", "yr"), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "PDO window", "NPGO year")) +
  scale_shape_manual(name="Mann Kendall test",  values=c("FALSE"=1, "TRUE"=16),  breaks = c("TRUE", "FALSE"),labels = c("True", "False"))

# Rows are MEF and columns are library factor
p2 <- p1 + facet_grid(env_fac ~ library)  

print(p2)

ggsave(filename = paste("Output/Figures/3_CCM_",name,".pdf", sep = ""), plot = p2, width = 7, height = 9.5, units = "in")  # saves the last plot

}



```
