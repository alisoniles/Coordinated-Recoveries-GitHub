---
title: "3_EDM_CCM_pairwise_causality"
author: "Alison Iles"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#load the necessary packages. 
Note that the `echo = FALSE` parameter prevents printing of the R code.

```{r, echo=FALSE}
library(rEDM)
library(reshape2)
library(ggplot2)
library(viridis)
library(gridExtra)
library(xtable)
library(rlist)
library(Kendall) #for MannKendall test
library(psych) #for paired.r function
library(tidyr)
library(stringr)
```


#Convergent Cross Mapping (CCM) with time delays
To test whether pairwise causality exists between the environmental variables and the spawner recruit relationship. Also to test all the lags for each environmental variable to figure out which is the best to use in the multivariate embeddings.

block_lnlp uses multiple time series given as input to generate an attractor reconstruction, and then applies the simplex projection or s-map algorithm to make forecasts. This method generalizes the simplex and s_map routines, and allows for "mixed" embeddings, where multiple time series can be used as different dimensions of an attractor reconstruction.

#Multivariate CCM for the major population groups using block_lnlp to be able to include effective spawners in library

```{r}
###--- nonlinear test for different major population groups
rm(list=ls())  
load("Data/Rdata/block_data.Rdata")  
      aa <- t(data.frame(as.list(names(block_data[[1]]))))
      rownames(aa) <- NULL #remove rownames
      bb <- data.frame(c(aa[16], aa[20:21], aa[25], aa[38:269] ))
      colnames(bb) <- c("variable")
      cc <- str_split_fixed(bb$variable, "[.]",n=3)
var_names <- cbind(bb,cc)
      colnames(var_names) <- c("name","cat","subcat","offset")
      
mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
  u <- 1
  for(u in  c(1,3,4,5)){
    data <- block_data[c(mpg==u)]
    mpgname <- as.character(data[[1]]$mpg[1])
  
    #concatenate the time series of each variable together
    keys <-c(names(data[[1]]))
    merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
    merged_data <- as.data.frame(merged_data)
    valid <-  is.finite(merged_data$rec3_n) & is.finite(merged_data$rec4_n) & is.finite(merged_data$rec5_n) & is.finite(merged_data$eff_n)
    block <- merged_data[valid,]  
    
    #List in lib the begin and end points of each stock and the break points within stocks
    lib <- matrix(NA, nrow = length(which(diff(block$year)!=1))+1, ncol = 2)
          lib[,1] <- c(1, which(diff(block$year)!=1)+1)
          lib[,2] <- c(which(diff(block$year)!=1), nrow(block))
    libsize <- round(seq(NROW(block)/8, NROW(block), by = NROW(block)/8))

    #set up output table
    library_vars <- c("rec3_n", "rec4_n", "rec5_n", "rec_n")
    
          #Determine best embedding dimension: E would be set to the best univariate embedding dimension for each lib_column variable:
          best_E <- matrix(NA, nrow = length(library_vars), ncol = 2) # Save the optimal embedding dimension for each library variable
          colnames(best_E) <- c("library","E")
          best_E[,1] <- t(library_vars)
          for(j in 1:length(library_vars)){
            data <- as.matrix(cbind(block$year, block[library_vars[j]]))
            rownames(data) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
                  simplex_output <- simplex(data, E = 1:10, silent = TRUE)
                  best_E[j,2] <-  min(simplex_output$E[simplex_output$rho>max(simplex_output$rho)-sd(simplex_output$rho)]) #choose the smallest E whose rho is within 1 stdv of the maximum rho
          }
    
    env_vars <- as.character(var_names[,1])
          CCM_outputlist <- expand.grid(env_vars, library_vars, stringsAsFactors = FALSE) 
          CCM_outputlist$temp <- CCM_outputlist$Var1
          CCM_outputlist <- separate(CCM_outputlist,temp, into=c("cat","subcat","offset"), sep = "[.]")              
          CCM_outputlist[,6:11] <- matrix(NA, nrow = NROW(CCM_outputlist), ncol = 6)
          colnames( CCM_outputlist) <- c("target","library","cat","subcat","offset","rho", "N", "95p_crit", "ccm_rho", "MannKendall", "FisherZ")
          CCM_outputlist <- merge(CCM_outputlist, best_E)
    
    
    #Perform multivariate cross mappings with eff_n in the embedding:      
    for(i in c(1:NROW(CCM_outputlist)) ){  
    
      library_var <- CCM_outputlist$library[i]
      target_var <- CCM_outputlist$target[i]
      
            #make lagged data block that matches the optimal E
            max_lag <- as.numeric(as.character(CCM_outputlist$E[i]))
                  if (max_lag==0){max_lag=1}
            library_block <- make_block(block[library_var], t=block$year, max_lag=max_lag, tau=1, lib=lib)
            CCMlibrarynames <- names(library_block)
            CCMlibrarynames <- CCMlibrarynames[-c(1)] #remove "time" from list of library column names with which to do the CCM
            #CCMlibrarynames <- as.character(cbind(t(CCMlibrarynames),"block$eff_n") )
       
      # CCM from library var to target var   
      data <- as.matrix(cbind(library_block, block[target_var]))
            rownames(data) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
      
xmap <-  block_lnlp(data, lib = lib, columns = CCMlibrarynames, target_column = target_var, method = c("simplex"), tp = 0, first_column_time = TRUE, silent = TRUE)
            CCM_outputlist[i,6] <- xmap$rho
            CCM_outputlist[i,7] <- xmap$num_pred
            CCM_outputlist[i,8] <- qnorm(0.95, sd = 1/sqrt(xmap$num_pred - 3)) #qnorm is used to look up percentiles of the standard normal distribution. The 0.95 quantile is the 95th percentile. qnorm produces the boundary value that the rho needs to be greater than. 
            
#-------------------------------------------------------------------------------------------------------------------------  
# Univariate CCM from library var to target var   
            data <- as.matrix(cbind(library_block[,1:2],block[target_var]))
            rownames(data) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
ccm <-  ccm(data, lib = lib, E = as.numeric(as.character(CCM_outputlist$E[i])), lib_column = library_var, target_column = target_var, tp = 0, lib_sizes = libsize, random_libs = TRUE, num_samples=100, replace=TRUE, RNGseed=2301, silent = TRUE)      
      
      # Test if rho is significantly different from 0 at p=0.05 level (done for Sockey in Ye et al. 2015)
      # Calculate the median, maximum, and 1st & 3rd quantile of rho
            rho_quant=as.matrix(aggregate(ccm[,c('rho')],by = list(as.factor(ccm$lib_size)), quantile, na.rm = TRUE)[,'x'])
                  rho_quant <- rho_quant[complete.cases(rho_quant*0),1:5] #removes rows with inf values
      CCM_outputlist$ccm_rho[i] <- signif(rho_quant[dim(rho_quant)[1],3],2) #save the cross map skill at max library size (50th percentile)
            
      #Test for monotonic trend in a time series z[t] based on the Kendall rank correlation of z[t] and t. 
            #Here the median, maximum, and 1st & 3rd quantiles of rho are tested, all need to be <0.05.
            ccmq=as.matrix(aggregate(ccm[,c('rho')],by = list(as.factor(ccm$lib_size)), quantile)[,'x'])
            ccmMK <- apply(ccmq[,2:5],2,MannKendall)
      CCM_outputlist$MannKendall[i] <- (ccmMK$`25%`[[2]]<0.05 & ccmMK$`50%`[[2]]<0.05 & ccmMK$`75%`[[2]]<0.05) # & ccmMK$`100%`[[2]]<0.05) not the last quantile as the plot often flattens out       
      # Tests that the max library z is significantly higher than the begining. 
      # Transforms the rho at the min library and max library length to a normally distributed Fisher's z value
            # Independent correlations, different sample sizes. Our small sample sizes are a disadvantage here.
      FZ <- paired.r(rho_quant[1,3],rho_quant[dim(rho_quant)[1],3], NULL, libsize[1], libsize[dim(rho_quant)[1]], twotailed=FALSE)
            CCM_outputlist$FisherZ[i] <- FZ$p            
#-------------------------------------------------------------------------------------------------------------------------             
            
    }
    
saveRDS(CCM_outputlist, file = paste("Output/Rdata/3_CCM/3_CCM_MPG_",mpgname,".RDS", sep = ""), compress = FALSE)

}
```

```{R}
#Figures
rm(list=ls())  
load("Data/Rdata/block_data.Rdata")  
  
mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
u <- 1

for(u in c(1,3,4,5)){
  data <- block_data[c(mpg==u)]
  mpgname <- as.character(data[[1]]$mpg[1])
  CCM_outputlist<- readRDS(paste("Output/Rdata/3_CCM/3_CCM_MPG_",mpgname,".RDS", sep = ""))

# sort output table by offset then category
d <-  CCM_outputlist[order(CCM_outputlist$offset),]
d <-  d[order(d$cat),]
d$offset <- as.numeric(d$offset)

# split into 2 figures, one for physical covariates and one for biological covariates
phys_d <- d[d$cat=="flow" | d$cat=="npgo" | d$cat=="pdo" | d$cat=="up48", ]
biol_d <- d[d$cat=="salm" | d$cat=="hatch" | d$cat=="pinn" | d$cat=="smelt" | d$cat=="SRKW", ]
  
values <-  rbind("jan"='#800000', "feb"='#e6194b', "mar"='#f58231', "apr"='#ffe119', "may"='#bfef45', "jun"='#3cb44b', "jul"='#469990', "aug"='#42d4f4', "sep"='#4363d8', "oct"='#000075', "nov"='#911eb4', "dec"='#f032e6',  "STI"='#cccccc', "LUSI"='#999999', "TUMI"='#666666',  "win"='#a9a9a9', "yr"='#a9a9a9', "mean"='#469990', "peak"='#42d4f4', "gageht"='#4363d8', "peakday"='#000075')
breaks  <- rbind("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec", "STI", "LUSI", "TUMI", "win", "yr", "mean", "peak", "gageht", "peakday")
labels <-  rbind("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "STI", "LUSI", "TUMI", "PDO window", "NPGO year", "River mean discharge", "River peak flow", "River gage hight", "River peak flow day")
phys_scm <- cbind(values,breaks,labels)
colnames(phys_scm) <- c("values","breaks","labels")

values <-  rbind("eff_n"='#ffe119',  "rec3_n"='#bfef45', "rec4_n"='#3cb44b', "harv_n"='#469990', "spring"='#800000', "summer"='#e6194b', "total"='#f58231', "CSLbonn"='#ffe119', "CSLhaulout"='#bfef45', "CSLmales"='#3cb44b', "CSLmales6"='#469990', "CSLpup"='#42d4f4',  "HSaerial"='#800000', "HSbonn"='#e6194b', "SSLaerial"='#000075', "SSLbonn"='#911eb4', "SSLrookORraw"='#f032e6', "TOTbonn"='#800000',  "CPUE"='#f58231', "ssb"='#ffe119', "Jpod"='#bfef45',"Kpod"='#3cb44b', "Lpod"='#469990', "KLpods"='#42d4f4', "JKLpods"='#4363d8', "JKLdeaths"='#000075', "JKLbirths"='#911eb4')
breaks  <- rbind("eff_n",  "rec3_n", "rec4_n", "harv_n", "spring", "summer", "total", "CSLbonn", "CSLhaulout", "CSLmales", "CSLmales6", "CSLpup", "HSaerial", "HSbonn", "SSLaerial", "SSLbonn", "SSLrookORraw", "TOTbonn", "CPUE", "ssb", "Jpod", "Kpod", "Lpod", "KLpods", "JKLpods", "JKLdeaths",     "JKLbirths")
labels <-  rbind("Spawners",  "3 yr old recruits", "4 year old recruits", "Harvest", "Hatchery spring", "Hatchery summer", "Hatchery total", "CSL Bonneville Dam", "CSL haulout", "CSL males", "CSL males 6+ yrs", "CSL pups","HS aerial survey", "HS Bonneville Dam", "SSL aerial survey", "SSL Bonneville Dam", "SSL rookery OR raw", "TOT Bonneville Dam", "Smelt CPUE", "Smelt ssb", "SRKW J pod", "SRKW K pod", "SRKW L pod", "SRKW KL pods", "SRKW JKL pods", "SRKW deaths", "SRKW births")
biol_scm <- cbind(values,breaks,labels)
colnames(biol_scm) <- c("values","breaks","labels")

#Plot of CCM of physical covariates
p1 <- ggplot(phys_d, aes(x=offset, y=rho)) +
    geom_line(aes(col=subcat)) +
    geom_point(aes(col=subcat, shape=(phys_d$MannKendall==TRUE))) +
    geom_vline(aes(xintercept=0), colour='#999999') +
    geom_hline(aes(yintercept=0), colour='#999999') +
    geom_hline(aes(yintercept=min(phys_d$'95p_crit')), colour='#999999', linetype="dashed") + #horizontal like for rho sig diff from zero
    theme_bw() + 
    guides(col = guide_legend(ncol=1)) +
    labs(title=paste(mpgname, "MPG", sep=" "), subtitle = "Multivariate CCM with spawners included in the attractor reconstruction", x="Environmental variable offset, year", y=expression(paste("Cross-mapping correlation, ", {rho}))) +  
    scale_color_manual(values = phys_scm[,1], name="Time series", breaks = phys_scm[,2], labels = phys_scm[,3]) +
  scale_shape_manual(name="MK test",  values=c("FALSE"=1, "TRUE"=16),  breaks = c("TRUE", "FALSE"),labels = c("True", "False"))
p2 <- p1 + facet_grid(cat ~ library)  
print(p2)
ggsave(filename = paste("Output/Figures/3_CCM/3_CCM_physical_covariates_",mpgname,".pdf", sep = ""), plot = p2, width = 7, height = 9.5, units = "in")  


#Plot of CCM of biological covariates
p1 <- ggplot(biol_d, aes(x=offset, y=rho)) +
    geom_line(aes(col=subcat)) +
    geom_point(aes(col=subcat, shape=(biol_d$MannKendall==TRUE))) +
    geom_vline(aes(xintercept=0), colour='#999999') +
    geom_hline(aes(yintercept=0), colour='#999999') +
    geom_hline(aes(yintercept=min(phys_d$'95p_crit')), colour='#999999', linetype="dashed") + #horizontal like for rho sig diff from zero
    theme_bw() + 
    guides(col = guide_legend(ncol=1)) +
    labs(title=paste(mpgname, "MPG", sep=" "), subtitle = "Multivariate CCM with spawners included in the attractor reconstruction", x="Environmental variable offset, year", y=expression(paste("Cross-mapping correlation, ", {rho}))) +  
    scale_color_manual(values = biol_scm[,1], name="Time series", breaks = biol_scm[,2], labels = biol_scm[,3]) +
  scale_shape_manual(name="MK test",  values=c("FALSE"=1, "TRUE"=16),  breaks = c("TRUE", "FALSE"),labels = c("True", "False"))
p2 <- p1 + facet_grid(cat ~ library)  
print(p2)
ggsave(filename = paste("Output/Figures/3_CCM/3_CCM_biological_covariates_",mpgname,".pdf", sep = ""), plot = p2, width = 7, height = 9.5, units = "in")  


  }
 
```
## Multivariate CCM for the major population groups using 'block_lnlp' and 'ccm' on the data block with no built in lags - evaluate lags in the code by varying tp.

By default, convergent cross mapping (via the ccm function) tries to map between a lagged-coordinate vector from a “library” variable, x, and the simultaneous value of a target variable, y, where tp=0.However, note that tp is also an argument to ccm, and will accept both positive and negative values. This allows us to identify the ability to infer F from the data at different values of tp, which is, to a first approximation, the time delay by which information about y is encoded in the time series of x. Note here that negative values of tp (tp<0) indicate that past values of y are best cross mapped from the reconstructed state of x⃗. This suggests a dynamical signal that appears first in y and later in x, and is consistent with y causing x. If there is no causation in the reverse direction (i.e. x does not cause y), then we would expect that CCM in the opposite direction would be best at a positive values of tp (tp>0).

This presumes that the time series are sampled frequently enough relative to the causation that a time delay can be detected. If causation is synchronous or nearly so, then we may find the optimal value of tp to be 0 in both directions.

This method doesn't take advange of the whole data set as the ends of the data are cut off with the lags, but it helps to ID which lags are important for each variable.
```{R}
rm(list=ls()) 

for(u in c(1,3,4,5)){
load("Data/Rdata/block_data_no_lags.Rdata")  
      aa <- t(data.frame(as.list(names(block_data_no_lags[[1]]))))
      rownames(aa) <- NULL #remove rownames
      bb <- data.frame(aa[-c(1:34, 36:37),]) 
      colnames(bb) <- c("variable")
      cc <- str_split_fixed(bb$variable, "[.]",n=3)
      var_names <- cbind(bb,cc)
      colnames(var_names) <- c("name","cat","subcat","offset")
      rm(aa, bb, cc)
      
      
      mpg <- c() 
        for(stk in 1:length(block_data_no_lags)) { 
            mpg[stk] <- block_data_no_lags[[stk]]$mpg[1]
        }
      data <- block_data_no_lags[c(mpg==u)]
      mpgname <- as.character(data[[1]]$mpg[1])
      rm(block_data_no_lags, mpg, stk)
  
    #concatenate the time series of each variable together
    keys <-c(names(data[[1]]))
    merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
    merged_data <- as.data.frame(merged_data)
    valid <-  is.finite(merged_data$rec3_n) & is.finite(merged_data$rec4_n) & is.finite(merged_data$rec5_n) & is.finite(merged_data$eff_n)
    block <- merged_data[valid,]  
    rownames(block) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
    rm(data, keys, merged_data, valid)
    
    #List in lib the begin and end points of each stock and the break points within stocks
    lib <- matrix(NA, nrow = length(which(diff(block$year)!=1))+1, ncol = 2)
    lib[,1] <- c(1, which(diff(block$year)!=1)+1)
    lib[,2] <- c(which(diff(block$year)!=1), nrow(block))
    libsize <- round(seq(NROW(block)/8, NROW(block), by = NROW(block)/8))

    #set up output table
    library_vars <- c("rec_n") 
          #Determine best embedding dimension for each library variable, set to the best univariate embedding dimension:
          best_E <- matrix(NA, nrow = length(library_vars), ncol = 2) # Save the optimal embedding dimension for each library variable
          colnames(best_E) <- c("library","E")
          best_E[,1] <- t(library_vars)
          for(j in 1:length(library_vars)){
            data <- as.matrix(cbind(block$year, block[library_vars[j]]))
            rownames(data) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
                  simplex_output <- simplex(data, E = 1:10, silent = TRUE)
                  best_E[j,2] <-  min(simplex_output$E[simplex_output$rho>max(simplex_output$rho)-sd(simplex_output$rho)]) #choose the smallest E whose rho is within 1 stdv of the maximum rho
                  best_E[,2] <- as.numeric(as.character(best_E[,2]))
          }
          rm(simplex_output, j, data)
    
          CCM_outputlist <- expand.grid(as.character(var_names[,1]), library_vars, tp=-5:5, stringsAsFactors = FALSE) 
          CCM_outputlist$temp <- CCM_outputlist$Var1
          CCM_outputlist <- separate(CCM_outputlist,temp, into=c("cat","subcat","offset"), sep = "[.]")
          CCM_outputlist$offset <- NULL #don't need this here
          CCM_outputlist[,6:11] <- matrix(NA, nrow = NROW(CCM_outputlist), ncol = 6)
          colnames( CCM_outputlist) <- c("target","library","tp", "cat","subcat", "rho", "N", "95p_crit","ccm_rho","MannKendall","FisherZ")
          CCM_outputlist <- merge(CCM_outputlist, best_E)
          rm(library_vars, best_E)

    #Perform cross mappings:      
    for(i in c(1:NROW(CCM_outputlist)) ){  
print(i)
      library_var <- CCM_outputlist$library[i]
      target_var <- CCM_outputlist$target[i]
      tp <- CCM_outputlist$tp[i]
      
      #make lagged data block that matches the optimal E, minus one because the number of effective spawners is added
            E <-  as.numeric(as.character(CCM_outputlist$E[i]))
            max_lag <- E-1
                  if (max_lag==0){max_lag=1}
            lnlp_block <- make_block(block[library_var], t=block$year, max_lag=max_lag, tau=1, lib=lib)
            lnlp_block <- as.matrix(cbind(lnlp_block, block[target_var])) # Multivariate CCM block_lnlp from library var to target var   
            rownames(lnlp_block) <- NULL #remove rownames to supress error in CCM: NAs introduced by coersion
      
xmap <- block_lnlp(lnlp_block, lib = lib, target_column = target_var, method = c("simplex"), tp = tp, first_column_time = TRUE, silent = TRUE)

            CCM_outputlist$rho[i] <- xmap$rho
            CCM_outputlist$N[i] <- xmap$num_pred
            CCM_outputlist$'95p_crit'[i] <- qnorm(0.95, sd = 1/sqrt(xmap$num_pred - 3)) #qnorm is used to look up percentiles of the standard normal distribution. The 0.95 quantile is the 95th percentile. qnorm produces the boundary value that the rho needs to be greater than. 
            
            
## Univariate CCM from library var to target var   
            ccm_block <- as.matrix(cbind(block$year, block[library_var], block[target_var]))
            
ccm <-  ccm(ccm_block, lib = lib, E = E, tp = tp, lib_column = library_var, target_column = target_var, lib_sizes = libsize, random_libs = TRUE, num_samples=100, replace=TRUE, RNGseed=2301, silent = TRUE)      
      
      # Test if rho is significantly different from 0 at p=0.05 level (done for Sockey in Ye et al. 2015)
      # Calculate the median, maximum, and 1st & 3rd quantile of rho
            rho_quant=as.matrix(aggregate(ccm[,c('rho')],by = list(as.factor(ccm$lib_size)), quantile, na.rm = TRUE)[,'x'])
            rho_quant <- rho_quant[complete.cases(rho_quant*0),1:5] #removes rows with inf values
            CCM_outputlist$ccm_rho[i] <- signif(rho_quant[dim(rho_quant)[1],3],2) #save the cross map skill at max library size (50th percentile)
            
      #Test for monotonic trend in a time series z[t] based on the Kendall rank correlation of z[t] and t. 
            #Here the median, maximum, and 1st & 3rd quantiles of rho are tested, all need to be <0.05.
            ccmq=as.matrix(aggregate(ccm[,c('rho')],by = list(as.factor(ccm$lib_size)), quantile)[,'x'])
            ccmMK <- apply(ccmq[,2:5],2,MannKendall)
            CCM_outputlist$MannKendall[i] <- (ccmMK$`25%`[[2]]<0.05 & ccmMK$`50%`[[2]]<0.05 & ccmMK$`75%`[[2]]<0.05 & ccmMK$`100%`[[2]]<0.05)    
            
      # Tests that the max library z is significantly higher than the begining. 
      # Transforms the rho at the min library and max library length to a normally distributed Fisher's z value
            # Independent correlations, different sample sizes. Our small sample sizes are a disadvantage here.
            FZ <- paired.r(rho_quant[1,3],rho_quant[dim(rho_quant)[1],3], NULL, libsize[1], libsize[dim(rho_quant)[1]], twotailed=FALSE)
            CCM_outputlist$FisherZ[i] <- FZ$p
            
            
            rm(library_var, target_var, tp, E, max_lag, lnlp_block, ccm_block, xmap, ccm, rho_quant, ccmq, ccmMK, FZ)
            
    }
      
 saveRDS(CCM_outputlist, file = paste("Output/Rdata/3_CCM/CCM_tp_",mpgname,".RDS", sep = ""), compress = FALSE)
}
```

```{R}
#Figures
rm(list=ls())  
load("Data/Rdata/block_data_no_lags.Rdata")  
  
mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
u <- 1

for(u in c(1,3,4,5)){
  data <- block_data[c(mpg==u)]
  mpgname <- as.character(data[[1]]$mpg[1])
  CCM_outputlist<- readRDS(paste("Output/Rdata/3_CCM/CCM_tp_",mpgname,".RDS", sep = ""))

#Figure
d <- CCM_outputlist

# split into 2 figures, one for physical covariates and one for biological covariates
phys_d <- d[d$cat=="flow" | d$cat=="npgo" | d$cat=="pdo" | d$cat=="up48", ]
biol_d <- d[d$cat=="hatch" | d$cat=="pinn" | d$cat=="smelt" | d$cat=="SRKW", ]
  
values <-  rbind("jan"='#800000', "feb"='#e6194b', "mar"='#f58231', "apr"='#ffe119', "may"='#bfef45', "jun"='#3cb44b', "jul"='#469990', "aug"='#42d4f4', "sep"='#4363d8', "oct"='#000075', "nov"='#911eb4', "dec"='#f032e6',  "STI"='#999999', "LUSI"='#666666', "TUMI"='#333333',  "win"='#333333', "yr"='#333333', "mean"='#469990', "peak"='#42d4f4', "gageht"='#4363d8', "peakday"='#000075')
breaks  <- rbind("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec", "STI", "LUSI", "TUMI", "win", "yr", "mean", "peak", "gageht", "peakday")
labels <-  rbind("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "STI", "LUSI", "TUMI", "PDO window", "NPGO year", "River mean flow", "River peak flow", "River gage height", "River peak day")
phys_scm <- cbind(values,breaks,labels)
colnames(phys_scm) <- c("values","breaks","labels")

values <-  rbind("spring"='#800000', "summer"='#e6194b', "total"='#f58231', "CSLbonn"='#ffe119', "CSLhaulout"='#bfef45', "CSLmales"='#3cb44b', "HSaerial"='#469990', "HSbonn"='#42d4f4', "SSLaerial"='#000075', "SSLbonn"='#911eb4', "SSLrookORraw"='#f032e6', "TOTbonn"='#800000', "CSLpup"='#e6194b',  "CPUE"='#f58231', "ssb"='#ffe119', "Jpod"='#bfef45',"Kpod"='#3cb44b', "Lpod"='#469990', "KLpods"='#42d4f4', "JKLpods"='#4363d8', "JKLdeaths"='#000075', "JKLbirths"='#911eb4')
breaks  <- rbind("spring", "summer", "total", "CSLbonn", "CSLhaulout", "CSLmales", "HSaerial", "HSbonn", "SSLaerial", "SSLbonn", "SSLrookORraw", "TOTbonn", "CSLpup", "CPUE", "ssb", "Jpod", "Kpod", "Lpod", "KLpods", "JKLpods", "JKLdeaths",     "JKLbirths")
labels <-  rbind("Hatchery spring", "Hatchery summer", "Hatchery total", "CSL Bonneville", "CSL haulout", "CSL males", "HS aerial survey", "HS Bonneville", "SSL aerial survey", "SSL Bonneville", "SSL rookery OR raw", "TOT Bonneville", "CSL pups","Smelt CPUE", "Smelt ssb", "SRKW J pod", "SRKW K pod", "SRKW L pod", "SRKW KL pods", "SRKW JKL pods", "SRKW deaths", "SRKW births")
biol_scm <- cbind(values,breaks,labels)
colnames(biol_scm) <- c("values","breaks","labels")

#Plot of CCM of physical covariates
p1 <- ggplot(phys_d, aes(x=tp, y=rho)) +
    geom_vline(aes(xintercept=0)) +
    geom_rect(aes(xmin=3, ymin=-0.25, xmax=5, ymax=0.55), color ='#cccccc', fill='#cccccc') +
    geom_line(aes(col=subcat)) +
    geom_point(aes(col=subcat, shape=(phys_d$rho>phys_d$'95p_crit'))) +
    theme_bw() + 
    guides(col = guide_legend(ncol=1)) +
    ylim(-0.25, 0.55) +
    labs(title=paste(mpgname, "MPG", sep=" "), subtitle = "Univeriate CCM withOUT spawners included in the attractor reconstruction", x="Environmental variable offset, year", y=expression(paste("Cross-mapping correlation, ", {rho}))) +  
    scale_color_manual(values = phys_scm[,1], name="Time series", breaks = phys_scm[,2], labels = phys_scm[,3]) +
    scale_shape_manual(name=expression(paste("95% ", {rho})),  values=c("FALSE"=1, "TRUE"=16),  breaks = c("TRUE", "FALSE"),labels = c("True", "False"))
p2 <- p1 + facet_grid(cat ~ library)  
ggsave(filename = paste("Output/Figures/3_CCM/3_CCM_physical_covariates_tp_",mpgname,".pdf", sep = ""), plot = p2, width = 7, height = 9.5, units = "in")  

#Plot of CCM of biological covariates
p1 <- ggplot(biol_d, aes(x=tp, y=rho)) +
    geom_vline(aes(xintercept=0)) +
    geom_rect(aes(xmin=3, ymin=-0.25, xmax=5, ymax=0.8), color ='#cccccc', fill='#cccccc') +
    geom_line(aes(col=subcat)) +
    geom_point(aes(col=subcat, shape=(biol_d$rho>biol_d$'95p_crit'))) +
    theme_bw() +  
    guides(col = guide_legend(ncol=1)) +
    ylim(-0.25, 0.8) +
    labs(title=paste(mpgname, "MPG", sep=" "), subtitle = "Univeriate CCM withOUT spawners included in the attractor reconstruction", x="Environmental variable offset, year", y=expression(paste("Cross-mapping correlation, ", {rho}))) +  
    scale_color_manual(values = biol_scm[,1], name="Time series", breaks = biol_scm[,2], labels = biol_scm[,3]) +
    scale_shape_manual(name=expression(paste("95% ", {rho})),  values=c("FALSE"=1, "TRUE"=16),  breaks = c("TRUE", "FALSE"),labels = c("True", "False"))
p2 <- p1 + facet_grid(cat ~ library)  
ggsave(filename = paste("Output/Figures/3_CCM/3_CCM_biological_covariates_tp_",mpgname,".pdf", sep = ""), plot = p2, width = 7, height = 9.5, units = "in")  

}

```
