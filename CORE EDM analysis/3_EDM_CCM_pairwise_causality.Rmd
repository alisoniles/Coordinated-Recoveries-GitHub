---
title: "3_EDM_CCM_pairwise_causality"
author: "Alison Iles"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#load the necessary packages. 
Note that the `echo = FALSE` parameter prevents printing of the R code.

```{r, echo=FALSE}
library(rEDM)
library(reshape2)
library(ggplot2)
library(gridExtra)
library(xtable)
library(rlist)
```


#Convergent Cross Mapping (CCM) with time delays
To test whether pairwise causality exists between the environmental variables and the spawner recruit relationship. Also to test all the lags for each environmental variable to figure out which is the best to use in the multivariate embeddings.

We tested all monthly values of PDO, Upwelling index (for both 45 and 48 degrees latitude) and NPGO, even though with have apriori knowledge of which months are likely the most important for salmon. 

block_lnlp uses multiple time series given as input to generate an attractor reconstruction, and then applies the simplex projection or s-map algorithm to make forecasts. This method generalizes the simplex and s_map routines, and allows for "mixed" embeddings, where multiple time series can be used as different dimensions of an attractor reconstruction.


```{r}

# determine the best embedding dimension to use first with simplex?
library(sm)
library(vioplot)


compute_ccm <- function()
{
    load("Data/Rdata/block_data.Rdata")
    env_names <- c("up45_jan",	"up45_feb",	"up45_mar",	"up45_apr",	"up45_may",	"up45_jun",	"up45_jul",	"up45_aug",	"up45_sep",	"up45_oct",	"up45_nov",	"up45_dec",	"up48_jan",	"up48_feb",	"up48_mar",	"up48_apr",	"up48_may",	"up48_jun",	"up48_jul",	"up48_aug",	"up48_sep",	"up48_oct",	"up48_nov",	"up48_dec", "pdo_jan",	"pdo_feb",	"pdo_mar",	"pdo_apr",	"pdo_may",	"pdo_jun",	"pdo_jul",	"pdo_aug",	"pdo_sep",	"pdo_oct",	"pdo_nov",	"pdo_dec", "pdo_win", "npgo_jan",	"npgo_feb",	"npgo_mar",	"npgo_apr",	"npgo_may",	"npgo_jun",	"npgo_jul",	"npgo_aug",	"npgo_sep",	"npgo_oct",	"npgo_nov",	"npgo_dec",	"npgo_yr")
    ccm_table <- do.call(rbind, lapply(block_data, function(stock_df) 
         {
        valid <- is.finite(stock_df$rec5_n) & is.finite(stock_df$eff_n)
        block <- stock_df[valid,]
        
        ccm_rhos <- do.call(cbind, lapply(env_names, function(env_var) {
            output <- block_lnlp(block, tp = 0, target_column = env_var, 
                                 columns = c("rec5_n", "eff_n"), silent = TRUE)
            return(output$rho)
        }))
        colnames(ccm_rhos) <- env_names
        ccm_rhos <- cbind(N = sum(valid), ccm_rhos)
        return(ccm_rhos)
    }))
    rownames(ccm_table) <- names(block_data)
    saveRDS(ccm_table, file = "results_ccm.RDS")
    return()
}

print_ccm_table <- function()
{
    ccm_table <- data.frame(readRDS("results_ccm.RDS"))
    ccm_table <- cbind("N" = ccm_table$N,
                       "95% p" = tanh(qnorm(0.95, sd = 1/sqrt(ccm_table$N - 3))), 
                       ccm_table[,2:NCOL(ccm_table)])
    my_table <- xtable(ccm_table, digits = 3)
    print(my_table, type = "html", file = "Output/Tables/Table_S3.html")
    return(ccm_table)
}

compute_ccm()
print_ccm_table() # table S3 in Sockeye paper
```

```{R}
quartz()
vioplot(ccm_table[,3:14], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec"))
title("CCM of upwelling at 45 degrees")
```

```{R}
vioplot(ccm_table[,15:26], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec"), title("CCM of upwelling at 48 degrees"))

```
```{R}
vioplot(ccm_table[,27:39], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec",  "Win"), title("CCM of PDO"))

```

```{R}
vioplot(ccm_table[,40:52], names=c("Jan",	"Feb",	"Mar",	"Apr",	"May",	"Jun",	"Jul",	"Aug",	"Sep",	"Oct",	"Nov",	"Dec", "Year"), title("CCM of NPGO"))

```

#Convergent cross-mapping test for the major population groups 

```{r}

compute_ccm_mpg <- function(data, name)
{
    #concatenate the time series of each variable together
        keys <-c(names(data[[1]]))
        merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
        merged_data <- as.data.frame(merged_data)
        valid <- is.finite(merged_data$rec4_n) & is.finite(merged_data$rec5_n) & is.finite(merged_data$eff_n)
        block <- merged_data[valid,]  
        
    #List in lib the begin and end points of each stock
        lib <- matrix(NA, nrow = length(which(diff(block$yr)!=1))+1, ncol = 2)
        lib[,1] <- c(1, which(diff(block$yr)!=1)+1)
        lib[,2] <- c(which(diff(block$yr)!=1), nrow(block))
        ## NOTE: library includes breaks between stocks AND non-continuous breaks within stocks
     
        env_names <- c(names(data[[1]][28:77]))
  
        ccm_table <- do.call(cbind, lapply(env_names, function(env_var) 
          {  output <- block_lnlp(block, lib, target_column = env_var, method = c("s-map"), theta = 2, tp=0, columns = c("rec4_n", "rec5_n", "eff_n"), save_smap_coefficients = TRUE)
            #For the tp parameter, the default value of 1 means that the program will predict the target variable 1 time step into the future (based on the row-structure of the input data). In some cases, the data may already be processed into a format where one wants to predict a different column that has already been aligned correctly. In that case, one can set tp = 0 when calling block_lnlp.
            return(output$rho)
        }))
        colnames(ccm_table) <- env_names
        ccm_table <- cbind(N = sum(valid), ccm_table)
        rownames(ccm_table) <- name
        
        ccm_table <- as.data.frame(ccm_table)
        ccm_table <- cbind("N" = ccm_table$N,
                       "95% p" = tanh(qnorm(0.95, sd = 1/sqrt(ccm_table$N - 3))), 
                       ccm_table[,2:NCOL(ccm_table)])
        ccm_table <- xtable(ccm_table, digits = 3)

        saveRDS(ccm_table, file = paste("Output/Rdata/results_ccm_",name,".RDS", sep = "", collapse = NULL))
    
    return()
}

###--- nonlinear test for different major population groups
load("Data/Rdata/block_data.Rdata")  
mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
  
  for(u in c(1, 3, 4, 5)){
    data <- block_data[c(mpg==u)]
    name <- as.character(data[[1]]$mpg[1])
    compute_ccm_mpg(data, name)
  }

    ccm_table_I <- data.frame(readRDS("Output/Rdata/results_ccm_Imnaha.RDS"))
    ccm_table_MFS <- data.frame(readRDS("Output/Rdata/results_ccm_Middle Fork Salmon.RDS"))
    ccm_table_SFS <- data.frame(readRDS("Output/Rdata/results_ccm_South Fork Salmon.RDS"))
    ccm_table_US <- data.frame(readRDS("Output/Rdata/results_ccm_Upper Salmon.RDS"))
    
    ccm_table <- rbind(ccm_table_I, ccm_table_MFS, ccm_table_SFS, ccm_table_US)
    saveRDS(ccm_table, file = "Output/Rdata/results_ccm_mpg.RDS", compress = FALSE)
    
    print(ccm_table, type = "html", file = "Output/Tables/CCM_MPG.html")
```

#univariate ccm
Setup the cross mapping runs we want to do:
```{R}
load("Data/Rdata/block_data.Rdata")  

mpg <- c() 
  for(stk in 1:length(block_data)) { 
      mpg[stk] <- block_data[[stk]]$mpg[1]
  } 
  
  #for(u in c(3)){   # for each mpg
    data <- block_data[c(mpg==u)]
    name <- as.character(data[[1]]$mpg[1])
  
    #concatenate the time series of each variable together
    keys <-c(names(data[[1]]))
    merged_data <-setNames(do.call(mapply, c(FUN=c, lapply(data, `[`, keys))), keys)
    merged_data <- as.data.frame(merged_data)
    valid <- is.finite(merged_data$rec4_n) & is.finite(merged_data$rec5_n) & is.finite(merged_data$eff_n)
    block <- merged_data[valid,]  
    
    #List in lib the begin and end points of each stock and the break points within stocks
    lib <- matrix(NA, nrow = length(which(diff(block$yr)!=1))+1, ncol = 2)
    lib[,1] <- c(1, which(diff(block$yr)!=1)+1)
    lib[,2] <- c(which(diff(block$yr)!=1), nrow(block))

    library_vars <- c("rec4_n", "rec5_n", "eff_n")
    target_vars <- env_names <- c("up45_jan",	"up45_feb",	"up45_mar",	"up45_apr",	"up45_may",	"up45_jun",	"up45_jul",	"up45_aug",	"up45_sep",	"up45_oct",	"up45_nov",	"up45_dec",	"up48_jan",	"up48_feb",	"up48_mar",	"up48_apr",	"up48_may",	"up48_jun",	"up48_jul",	"up48_aug",	"up48_sep",	"up48_oct",	"up48_nov",	"up48_dec", "pdo_jan",	"pdo_feb",	"pdo_mar",	"pdo_apr",	"pdo_may",	"pdo_jun",	"pdo_jul",	"pdo_aug",	"pdo_sep",	"pdo_oct",	"pdo_nov",	"pdo_dec", "pdo_win", "npgo_jan",	"npgo_feb",	"npgo_mar",	"npgo_apr",	"npgo_may",	"npgo_jun",	"npgo_jul",	"npgo_aug",	"npgo_sep",	"npgo_oct",	"npgo_nov",	"npgo_dec",	"npgo_yr")
    
    # generate all combinations of lib_column, target_column, tp
    params <- expand.grid( target_column = target_vars, 
                           tp = -5:5)
     
    #params <- params[params$lib_column != params$target_column, ] # throw out cases where lib == target. Not need as library stays the same
    
     #what is the best theta? First determine the best embedding dimension of each variable in the library
            simplex_output <- simplex(block$eff_n, lib = lib, pred = lib, E = 1:8, exclusion_radius = 0, silent = TRUE)
            best_rho_E <- simplex_output$E[which.max(simplex_output$rho)]
            best_mae_E <- simplex_output$E[which.min(simplex_output$mae)]
            eff_E <- min(best_rho_E, best_mae_E)
            
            simplex_output <- simplex(block$rec5_n, lib = lib, pred = lib, E = 1:8, exclusion_radius = 0, silent = TRUE)
            best_rho_E <- simplex_output$E[which.max(simplex_output$rho)]
            best_mae_E <- simplex_output$E[which.min(simplex_output$mae)]
            rec5_E <- min(best_rho_E, best_mae_E)
            
            simplex_output <- simplex(block$rec4_n, lib = lib, pred = lib, E = 1:8, exclusion_radius = 0, silent = TRUE)
            best_rho_E <- simplex_output$E[which.max(simplex_output$rho)]
            best_mae_E <- simplex_output$E[which.min(simplex_output$mae)]
            rec4_E <- min(best_rho_E, best_mae_E)
            
            best_E <- max(eff_E, rec5_E, rec4_E)
            
            s_map_output <- s_map(block$eff_n, lib, pred = lib, E=eff_E)
            best_rho_theta <- s_map_output$theta[which.max(s_map_output$rho)]
            best_mae_theta <- s_map_output$theta[which.min(s_map_output$mae)]
            
            
    #Perform cross mapping runs:  
    output <- do.call(rbind, lapply(seq_len(NROW(params)), function(i) {
        block_lnlp(block, lib, 
        columns = library_vars, 
        target_column = params$target_column[i], 
        method = c("s-map"), theta = 2,
        tp = params$tp[i], silent = FALSE)
        }))

    
#Create an additional column to describe the direction of the cross mapping:
output$direction <- paste("xmap to", output$target_column)

#Plot the results (cross map skill vs. tp):
ggplot(output, aes(x = tp, y = rho, color = direction))  + geom_line() + theme_bw()

}
```